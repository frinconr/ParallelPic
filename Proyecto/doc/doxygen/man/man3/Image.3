.TH "Image" 3 "Mon Dec 9 2013" "Version 1.0" "ParallelPic" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Image \- 
.PP
The \fBImage\fP class is the abstraction of the image, contains a CImg object that defines the handling of the image\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ParallelPic\&.hh>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBImage\fP ()"
.br
.RI "\fIConstructor This constructor initializes the four dimension params at 0; The Img calls the constructor of CImg to create an empty image\&. \fP"
.ti -1c
.RI "\fBImage\fP (const char *const filename)"
.br
.RI "\fI\fBImage()\fP is the constructor of the image used when the image doesn't been be created\&. \fP"
.ti -1c
.RI "\fBImage\fP (const unsigned int width, const unsigned int height, const unsigned int depth, const unsigned int spectrum, int value)"
.br
.RI "\fI\fBImage\fP (const char *const filename) this constructor is used when the image already exist's and is stored in\&. \fP"
.ti -1c
.RI "\fB~Image\fP (void)"
.br
.ti -1c
.RI "void \fBdisplay\fP (const char *message)"
.br
.ti -1c
.RI "void \fBset_pixel_value\fP (int x, int y, int z, int c, unsigned char)"
.br
.ti -1c
.RI "\fBImage\fP \fBsubstract_img\fP (\fBImage\fP, int)"
.br
.RI "\fIThis function substracts the pixel values of two images, that can be used to see the differences between them\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBsum_img\fP (\fBImage\fP, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBmultiply_img\fP (double, int)"
.br
.RI "\fIThis function multiplies the pixel values by a factor\&. If the pixel value is higher than 255, adjust the pixel value to 255\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBbinarize_img\fP (unsigned int, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Laplacian\fP (int)"
.br
.RI "\fIReturns an image after applying the Laplacian filter to the image\&. Considers the diagonal values This function applies a convolution with this kernel: $ ((1, 1, 1), (1, -8, 1), (1, 1, 1)) $\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_Laplacian_no_diagonal\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Gradient_vertical\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Gradient_horizontal\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Prewitt_N_S\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Prewitt_NE_SW\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Prewitt_E_W\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_Prewitt_NW_SE\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_edge_enhacement_displacement\fP (unsigned int, unsigned int, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_horizontal_borders\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_vertical_borders\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_median\fP (int, int)"
.br
.RI "\fIThis function calculates the median of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_average\fP (int, int)"
.br
.RI "\fIThis function calculates the average of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBaverage_omp\fP (int, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_gaussian\fP (int, int, int)"
.br
.RI "\fIThis function applies a gaussian kernel trough the hole image\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_modal\fP (int, int)"
.br
.RI "\fIThis function calculates the modal of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBmedian_omp\fP (int, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_dynamic_range_dilatation\fP (unsigned char, unsigned char, double, double, double, int)"
.br
.RI "\fIAll the pixel values are divided in 3 ranges, and each range suffer a diferent transformation\&. This function is used to transform the range of lower pixel values in medium values and the higher too, to smooth the image\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBinverse\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBlog_transformation\fP (int)"
.br
.ti -1c
.RI "\fBImage\fP \fBpower_law_transformatiom\fP (double exponent, int)"
.br
.RI "\fIExecutes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBcolor_slicing\fP (unsigned char[], unsigned char[], unsigned char[], int)"
.br
.RI "\fIHighlights the desired colors, between the two colors given as parameters\&. \fP"
.ti -1c
.RI "int * \fBget_histogram\fP (unsigned int c, unsigned int z)"
.br
.ti -1c
.RI "void \fBplot_histogram\fP (int, const char *title)"
.br
.RI "\fIThis function plot the histogram, using the CImg histogram function\&. \fP"
.ti -1c
.RI "int * \fBhistogram_equalization\fP (int *, const char *title)"
.br
.ti -1c
.RI "CImg< float > \fBautocovariance\fP (int, int, int)"
.br
.RI "\fICalculates the autocovariance matrix for the image\&. The covariance, calculates the covariance matrix of an image\&. This function calculates something similar to the function below: $ g(x,y) = \sum \limits_{n=0}^{N} \sum \limits_{m=1}^M \left( f(x,y) - \overline{f(x,y)}\right)\left(f(x + \Delta x, y + \Delta y) - \overline{f(x + \Delta x, y + \Delta y)} \right) $ Where it calculates the variation between two series, one is the normal one, and the other is displaced by two parameters $ x$ & $ y$\&. For an image it its calculated for a neighborhood around each pixel\&. \fP"
.ti -1c
.RI "void \fBplot_histogram_equalization\fP (int, const char *title)"
.br
.ti -1c
.RI "\fBImage\fP \fBfilter_order_stadistics\fP (int dim, int order, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBvariance\fP (int, int)"
.br
.RI "\fIThis function compute the variance of an image\&. The variance is gived by the summation of the average multiplied by the substraction of the average with the pixel value, squared\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_0\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 0°\&. $(-3,-3,5)(-3,0,5)(-3,-3,5)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_45\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 45°\&. $(-3,5,5)(-3,0,5)(-3,-3,-3)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_90\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 90°\&. $(5,5,5)(-3,0-3)(-3,-3,-3)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_135\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 135°\&. $(5,5,-3)(5,0,-3)(-3,-3,-3)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_180\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 180°\&. $(5,-3,-3)(5,0,-3)(5,-3,-3)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_225\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 225°\&. $(-3,-3,-3)(5,0,-3)(5,5,-3)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_270\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 270°\&. $(-3,-3,-3)(-3,0,-3)(5,5,5)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_kirsch_315\fP (int)"
.br
.RI "\fIApplies the kirsch mask at 315°\&. $(-3,-3,-3)(-3,0,5)(-3,5,5)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_0\fP (int)"
.br
.RI "\fIApplies the freeman mask $(1,1,1)(1,-2,1)(1,-1,-1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_1\fP (int)"
.br
.RI "\fIApplies the freeman mask $(1,1,1)(-1,-2,1)(1,-1,1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_2\fP (int)"
.br
.RI "\fIApplies the freeman mask $)-1,1,1)(-1,-2,1)(1,1,1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_3\fP (int)"
.br
.RI "\fIApplies the freeman mask $(-1,-1,1)(-1,-2,1)(1,1,1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_4\fP (int)"
.br
.RI "\fIApplies the freeman mask $(-1,-1,-1)(1,-2,1)(1,1,1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_5\fP (int)"
.br
.RI "\fIApplies the freeman mask $(1,-1,-1)(1,-2,-1)(1,1,1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_6\fP (int)"
.br
.RI "\fIApplies the freeman mask $(1,1,-1)(1,-2,-1)(1,1,-1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_freeman_7\fP (int)"
.br
.RI "\fIApplies the freeman mask $(1,1,1)(1,-2,-1)(1,-1,-1)$\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_maximum\fP (int)"
.br
.RI "\fIAssigns the highest value in the neighborhood\&. Assigns the highest value in the neighborhood around the desired pixel\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBfilter_minimum\fP (int)"
.br
.RI "\fIAssigns the highest value in the neighborhood\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBgray_scale\fP (int)"
.br
.RI "\fIAssigns the lowest value in the neighborhood\&. \fP"
.ti -1c
.RI "void \fBgaussian_noise\fP (double, int)"
.br
.RI "\fIConverts an RGB image to gray scale\&. \fP"
.ti -1c
.RI "void \fBsalt_pepper\fP (double, int)"
.br
.RI "\fIPut pepper (black pixels) and salt(white pixels) \fP"
.ti -1c
.RI "\fBImage\fP \fBinterpolation\fP (int)"
.br
.RI "\fIThis function doubles the size of the image and use the closer neighborhood interpolation\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBcoorrelogram\fP (unsigned int, unsigned int, int)"
.br
.RI "\fIThis function compute the coorrelogram of an image\&. \fP"
.ti -1c
.RI "\fBImage\fP \fBcoorrelogram_ZC\fP (unsigned int, unsigned int, unsigned int, unsigned int, int)"
.br
.ti -1c
.RI "\fBImage\fP \fBcoorrelogram_par\fP (unsigned int, unsigned int, unsigned int, unsigned int)"
.br
.ti -1c
.RI "\fBImage\fP \fBrgb_hsv\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBImage\fP class is the abstraction of the image, contains a CImg object that defines the handling of the image\&. 

This class have the attributes of the four dimensions of the image: height, width, depth and spectrum 
.PP
Definition at line 21 of file ParallelPic\&.hh\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Image::Image ()"

.PP
Constructor This constructor initializes the four dimension params at 0; The Img calls the constructor of CImg to create an empty image\&. 
.PP
Definition at line 17 of file image\&.cpp\&.
.PP
.nf
18 {
19     this->Img = new CImg<unsigned char>();
20     this->width = 0;
21     this->height = 0;
22     this->depth = 0;
23     this->spectrum = 0;
24 
25 }
.fi
.SS "Image::Image (const char *constfilename)"

.PP
\fBImage()\fP is the constructor of the image used when the image doesn't been be created\&. Constructor\&.
.PP
This constructor is used when the image already exist's and is stored in the
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP path\&. 
.RE
.PP

.PP
\fBParameters:\fP
.RS 4
\fI<Img>\fP is a var of type Cimg that is treated like an unsigned char\&.
.br
\fI<width>\fP refers to the number of columns of pixels in the image\&.
.br
\fI<height>\fP refers to the number of rows of pixels in the image\&.
.br
\fI<depth>\fP is the amount of layers of depth the image has, usually is one, except for 3D images\&.
.br
\fI<spectrum>\fP is the number of channels in the image, RGB has a spectrum of 3, a monocromatic image has a spectrum of 1\&. 
.RE
.PP

.PP
Definition at line 32 of file image\&.cpp\&.
.PP
.nf
33 {
34     this->Img = new CImg<unsigned char>(filename);
36     this->width = this->Img->width();
38     this->height = this->Img->height();
40     this->depth = this->Img->depth();
42     this->spectrum = this->Img->spectrum();
44 }
.fi
.SS "Image::Image (const unsigned intwidth, const unsigned intheight, const unsigned intdepth, const unsigned intspectrum, intvalue)"

.PP
\fBImage\fP (const char *const filename) this constructor is used when the image already exist's and is stored in\&. This constructor is used when we need to create an image, and gives the dimensions of the image, and the value of a color that fills all the pixels\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\&.\fP 
.RE
.PP

.PP
Definition at line 49 of file image\&.cpp\&.
.PP
.nf
50 {
51     this->Img = new CImg<unsigned char>(width, height, depth, spectrum, value);
52     this->width = width;
53     this->height = height;
54     this->depth = depth;
55     this->spectrum = spectrum;
56 }
.fi
.SS "Image::~Image (void)"
\fBImage\fP (const unsigned int width, const unsigned int height, const unsigned int depth, const unsigned int spectrum, int value) This constructor is used when we try to create an image with the specified dimensions and the parameter
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP is the value of the color of all the pixels of the image\&. 
.RE
.PP

.PP
Definition at line 60 of file image\&.cpp\&.
.PP
.nf
61 {
62     
63 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "CImg< float > Image::autocovariance (inthor_dis, intver_dis, intnum_threads)"

.PP
Calculates the autocovariance matrix for the image\&. The covariance, calculates the covariance matrix of an image\&. This function calculates something similar to the function below: $ g(x,y) = \sum \limits_{n=0}^{N} \sum \limits_{m=1}^M \left( f(x,y) - \overline{f(x,y)}\right)\left(f(x + \Delta x, y + \Delta y) - \overline{f(x + \Delta x, y + \Delta y)} \right) $ Where it calculates the variation between two series, one is the normal one, and the other is displaced by two parameters $ x$ & $ y$\&. For an image it its calculated for a neighborhood around each pixel\&. 
.PP
\fBReturns:\fP
.RS 4
A CImg object, because it must contain float values\&. 
.RE
.PP

.PP
Definition at line 2047 of file image\&.cpp\&.
.PP
.nf
2048 {
2049     CImg<float> autocovariance (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
2050     
2051     Image average = this->filter_average(1);
2052 
2053     for(unsigned int c = 0; c < this->get_spectrum(); c++)
2054     {
2055         for(unsigned int z = 0; z < this->get_depth(); z++)
2056         {
2057             for(unsigned int x = 3+hor_dis; x < this->get_width()-(3+hor_dis); x++)
2058             {
2059                 for(unsigned int y = 3+ver_dis; y < this->get_height()-(3+ver_dis); y++)
2060                 {
2061                     int sum = 0;
2062                     for(unsigned int i = x-3; i<x+4; i++)
2063                     {
2064                         for(unsigned int j= y-3; j<y+4; j++)
2065                         {
2066                             sum += ( (this->get_pixel_value(i,j,z,c))  -  average\&.get_pixel_value(i,j,z,c)) * ( (this->get_pixel_value(i+hor_dis,j+ver_dis,z,c))  -  average\&.get_pixel_value(i+hor_dis,j+ver_dis,z,c)) ;
2067                         }
2068                     }
2069                 
2070                     autocovariance(x,y,z,c) = sum/49;
2071                 }
2072             }
2073         }
2074      }
2075     return autocovariance;
2076 }
.fi
.SS "\fBImage\fP Image::average_omp (int, int)"

.SS "\fBImage\fP Image::binarize_img (unsigned intcutoff_value, intnum_threads)"

.PP
Definition at line 301 of file image\&.cpp\&.
.PP
.nf
302 {
303     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);
304     for(unsigned int c = 0; c < this->get_spectrum(); c++)
305     {
306         for(unsigned int z = 0; z < this->get_depth(); z++)
307         {
308             for(unsigned int x = 0; x < this->get_width(); x++)
309             {
310                 for(unsigned int y = 0; y < this->get_height(); y++)
311                 {
312                     unsigned char pixel= static_cast<unsigned int>(this->get_pixel_value(x,y,z,c));
313                     if(pixel >= cutoff_value)
314                         pixel=255;
315                     else
316                         pixel=0;
317                     result\&.set_pixel_value(x,y,z,c,pixel);
318 
319                 }
320             }
321         }
322     }
323 
324     
325     return result;
326 }
.fi
.SS "\fBImage\fP Image::color_slicing (unsigned charcolor1[], unsigned charcolor2[], unsigned charneutral[], intnum_threads)"

.PP
Highlights the desired colors, between the two colors given as parameters\&. 
.PP
\fBAttention:\fP
.RS 4
{The colors must be unsigned char, and must be the size of the spectrum of the image (Number of channels), 3 in case o RBG images} 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIunsigned\fP char color1[]: The start color of the color slicing\&. 
.br
\fIunsigned\fP char color2[]: The end color of the color slicing\&. 
.br
\fIunsigned\fP char neutral: The intensity every other pixels that are not between the given colors will be set to\&. 
.RE
.PP

.PP
Definition at line 1124 of file image\&.cpp\&.
.PP
.nf
1125 {
1126     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1127     
1128     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1129     {
1130         for(unsigned int z = 0; z < this->get_depth(); z++)
1131         {
1132             for(unsigned int x = 0; x < this->get_width(); x++)
1133             {
1134                 for(unsigned int y = 0; y < this->get_height(); y++)
1135                 {
1136                     unsigned char pixel = this->get_pixel_value(x,y,z,c);
1137                     if(pixel > color1[c] && pixel < color2[c] )
1138                     {
1139                         filtered\&.set_pixel_value(x, y, z, c, pixel);
1140                     }
1141                     else
1142                     {
1143                         filtered\&.set_pixel_value(x,y,z,c, neutral[c]);
1144                     }
1145                 }
1146                 
1147              }
1148              
1149          }
1150     }  
1151     
1152     return filtered;
1153     
1154 }
.fi
.SS "\fBImage\fP Image::coorrelogram (unsigned intver, unsigned inthor, intnum_threads)"

.PP
This function compute the coorrelogram of an image\&. This function compute the coorrelogram of a specified depth and spectrum of an image\&.
.PP
\fBParameters:\fP
.RS 4
\fIunsigned\fP int ver is the vertical distance of the original pixel that we use to compute the coorrelogram\&. 
.br
\fIunsigned\fP int hor is the horizontal distance of the original pixel that we use to compute the coorrelogram\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns the coorrelogram image\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIunsigned\fP int ver is the vertical distance of the original pixel that we use to compute the coorrelogram\&. 
.br
\fIunsigned\fP int hor is the horizontal distance of the original pixel that we use to compute the coorrelogram\&. 
.br
\fIunsigned\fP int z is the specified depth of the image that will be obtained the coorrelogram\&. 
.br
\fIunsigned\fP int c is the specified spectrum of the image that will be obtained the coorrelogram\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns the coorrelogram image\&. 
.RE
.PP

.PP
Definition at line 2164 of file image\&.cpp\&.
.PP
.nf
2165 {
2166     
2167     Image result (256,256, 1, 1, 0);    
2168     
2169     for(unsigned int i = 0; i < 256; i++)
2170     {
2171         for(unsigned int j=0; j< 256; j++)
2172         {
2173             unsigned int pixel = 0;
2174             
2175             for(unsigned int x=0; x< (this->get_width()-hor);++x)
2176             {
2177                 
2178                 for(unsigned int y=0; y< (this->get_height()-ver);++y)
2179                 {
2180                     unsigned char first = (this->get_pixel_value(x,y,0,0));
2181                     unsigned char secnd = (this->get_pixel_value(x+hor, y+ver, 0, 0));
2182                     
2183                     if(first == i && secnd == j)
2184                     {
2185                         pixel ++;
2186                     }
2187                 }
2188             }
2189             if(pixel>255)
2190             {
2191                 pixel=255;
2192             }
2193             
2194             result\&.set_pixel_value(i, j, 0, 0, pixel);
2195             
2196         }
2197         
2198         cout<<"\n"<<i<<"\n"<<endl;  
2199     }
2200     return result;
2201 
2202 }
.fi
.SS "\fBImage\fP Image::coorrelogram_par (unsignedint, unsignedint, unsignedint, unsignedint)"

.SS "\fBImage\fP Image::coorrelogram_ZC (unsigned intver, unsigned inthor, unsigned intz, unsigned intc, intnum_threads)"

.PP
Definition at line 2212 of file image\&.cpp\&.
.PP
.nf
2213 {
2214     
2215     Image result (256,256, 1, 1, 0);    
2216     
2217     for(unsigned int i = 0; i < 256; i++)
2218     {
2219         for(unsigned int j=0; j< 256; j++)
2220         {
2221             unsigned int pixel = 0;
2222             
2223             for(unsigned int x=0; x< (this->get_width()-hor);++x)
2224             {
2225                 
2226                 for(unsigned int y=0; y< (this->get_height()-ver);++y)
2227                 {
2228                     unsigned char first = (this->get_pixel_value(x,y,z,c));
2229                     unsigned char secnd = (this->get_pixel_value(x+hor, y+ver, z, c));
2230                     if(first == i && secnd == j)
2231                     {
2232                         pixel ++;
2233                     }
2234                 }
2235             }
2236             if(pixel>255)
2237             {
2238                 pixel=255;
2239             }
2240 
2241             result\&.set_pixel_value(i, j, 0, 0, pixel);
2242             
2243         }
2244         
2245     }
2246     return result;
2247 
2248 }
.fi
.SS "void Image::display (const char *message)"

.PP
Definition at line 77 of file image\&.cpp\&.
.PP
.nf
78 {
79     CImgDisplay main (*(this->Img), message);
80     while(!main\&.is_closed())
81     {
82         main\&.wait();
83     }
84 }
.fi
.SS "\fBImage\fP Image::filter_average (intdim, intnum_threads)"

.PP
This function calculates the average of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIOnly\fP receives the dimension of the kernel (dim), wich only can be an impair number\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP filtered which is the image with the average filter applied\&. 
.RE
.PP

.PP
Definition at line 803 of file image\&.cpp\&.
.PP
Referenced by autocovariance()\&.
.PP
.nf
804 {
805     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
806 
807     for(unsigned int c = 0; c < this->get_spectrum(); c++)
808     {
809         for(unsigned int z = 0; z < this->get_depth(); z++)
810         {
811             for(unsigned int x = dim; x < this->get_width()-dim; x++)
812             {
813                 for(unsigned int y = dim; y < this->get_height()-dim; y++)
814                 {
815                     int sum = 0;
816                     for(unsigned int i = x-dim; i<= x+dim; i++)
817                     {
818                         for(unsigned int j = y-dim; j<= y+dim; j++)
819                         {
820                             sum += this->get_pixel_value(i, j, z, c);
821                         }
822                     }
823             
824                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (sum/((dim*2+1)*(dim*2+1)));
825                     filtered\&.set_pixel_value(x, y, z, c, pixel);
826                 }
827                 
828              }
829              
830          }
831     }  
832      return filtered;   
833 } 
.fi
.SS "\fBImage\fP Image::filter_dynamic_range_dilatation (unsigned chara, unsigned charb, doublealpha, doublebeta, doublegamma, intnum_threads)"

.PP
All the pixel values are divided in 3 ranges, and each range suffer a diferent transformation\&. This function is used to transform the range of lower pixel values in medium values and the higher too, to smooth the image\&. 
.PP
\fBParameters:\fP
.RS 4
\fIunsigned\fP char a is the first cutoff pixel value\&. 
.br
\fIunsigned\fP char b is the second cutoff pixel value\&. 
.br
\fIdouble\fP alpha is the first multiplier\&. 
.br
\fIdouble\fP beta is the second multiplier\&. 
.br
\fIdouble\fP gamma is the third multiplier\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An image object that contains the dilatated image\&. 
.RE
.PP

.PP
Definition at line 1052 of file image\&.cpp\&.
.PP
.nf
1053 {
1054     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1055     
1056     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1057     {
1058         for(unsigned int z = 0; z < this->get_depth(); z++)
1059         {
1060             for(unsigned int x = 0; x < this->get_width(); x++)
1061             {
1062                 for(unsigned int y = 0; y < this->get_height(); y++)
1063                 {
1064                     unsigned char pixel=0;
1065                     
1066                     if(this->get_pixel_value(x,y,z,c)<a)
1067                         pixel =abs(alpha*this->get_pixel_value(x,y,z,c));
1068                         
1069                     else if(this->get_pixel_value(x,y,z,c)>=a && this->get_pixel_value(x,y,z,c)<b)
1070                         pixel=abs(beta*(this->get_pixel_value(x,y,z,c)-a)+alpha*a);
1071                     
1072                     else if(this->get_pixel_value(x,y,z,c)<=b)
1073                         
1074                         pixel=abs(gamma*(this->get_pixel_value(x,y,z,c)-b)+((beta*(b-a))+alpha*a));
1075                     filtered\&.set_pixel_value(x,y,z,c,static_cast<unsigned int>(pixel));
1076                 }
1077             }
1078         }
1079     }
1080     return filtered;
1081 }
.fi
.SS "\fBImage\fP Image::filter_edge_enhacement_displacement (unsigned inthorizontal_dis, unsigned intvertical_dis, intnum_threads)"

.PP
Definition at line 662 of file image\&.cpp\&.
.PP
.nf
663 {
664     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
665     if((horizontal_dis < this->get_width()) && (vertical_dis < this->get_height()))
666     {
667         for(unsigned int c = 0; c < this->get_spectrum(); c++)
668         {
669             for(unsigned int z = 0; z < this->get_depth(); z++)
670             {
671                 for(unsigned int x = horizontal_dis; x < this->get_width(); x++)
672                 {
673                     for(unsigned int y = vertical_dis; y < this->get_height(); y++)
674                     {
675                         unsigned char value = static_cast<unsigned char>(abs(this->get_pixel_value(x,y,z,c) - this->get_pixel_value(x-horizontal_dis, y-vertical_dis, z, c)));
676                         
677                         result\&.set_pixel_value(x,y,z,c, value);
678                     }
679                 }
680             }
681         }
682     }
683     return result;
684 }
.fi
.SS "\fBImage\fP Image::filter_freeman_0 (intnum_threads)"

.PP
Applies the freeman mask $(1,1,1)(1,-2,1)(1,-1,-1)$\&. 
.PP
Definition at line 1510 of file image\&.cpp\&.
.PP
.nf
1511 {
1512     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1513     
1514     int m = 1;
1515     
1516     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1517     {
1518         for(unsigned int z = 0; z < this->get_depth(); z++)
1519         {
1520             for(unsigned int x = m; x < this->get_width()-m; x++)
1521             {
1522                 for(unsigned int y = m; y < this->get_height()-m; y++)
1523                 {
1524                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1,y,z,c))-1*(get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+-2*get_pixel_value(x, y, z, c);
1525                     if (sum > 255 || sum < -255)
1526                     {
1527                         sum = 255;
1528                     }
1529                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1530                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1531                 }
1532                 
1533              }
1534              
1535          }
1536     }  
1537     
1538     return filtered;
1539     
1540 }
.fi
.SS "\fBImage\fP Image::filter_freeman_1 (intnum_threads)"

.PP
Applies the freeman mask $(1,1,1)(-1,-2,1)(1,-1,1)$\&. 
.PP
Definition at line 1545 of file image\&.cpp\&.
.PP
.nf
1546 {
1547     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1548     
1549     int m = 1;
1550     
1551     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1552     {
1553         for(unsigned int z = 0; z < this->get_depth(); z++)
1554         {
1555             for(unsigned int x = m; x < this->get_width()-m; x++)
1556             {
1557                 for(unsigned int y = m; y < this->get_height()-m; y++)
1558                 {
1559                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1,y,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y+1, z, c))+-2*get_pixel_value(x, y, z, c);
1560                     if (sum > 255 || sum < -255)
1561                     {
1562                         sum = 255;
1563                     }
1564                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1565                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1566                 }
1567                 
1568              }
1569              
1570          }
1571     }  
1572     
1573     return filtered;
1574     
1575 }
.fi
.SS "\fBImage\fP Image::filter_freeman_2 (intnum_threads)"

.PP
Applies the freeman mask $)-1,1,1)(-1,-2,1)(1,1,1)$\&. 
.PP
Definition at line 1580 of file image\&.cpp\&.
.PP
.nf
1581 {
1582     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1583     
1584     int m = 1;
1585     
1586     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1587     {
1588         for(unsigned int z = 0; z < this->get_depth(); z++)
1589         {
1590             for(unsigned int x = m; x < this->get_width()-m; x++)
1591             {
1592                 for(unsigned int y = m; y < this->get_height()-m; y++)
1593                 {
1594                     int sum = (get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1,y+1,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c))+-2*get_pixel_value(x, y, z, c);
1595                     if (sum > 255 || sum < -255)
1596                     {
1597                         sum = 255;
1598                     }
1599                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1600                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1601                 }
1602                 
1603              }
1604              
1605          }
1606     }  
1607     
1608     return filtered;
1609     
1610 }
.fi
.SS "\fBImage\fP Image::filter_freeman_3 (intnum_threads)"

.PP
Applies the freeman mask $(-1,-1,1)(-1,-2,1)(1,1,1)$\&. 
.PP
Definition at line 1615 of file image\&.cpp\&.
.PP
.nf
1616 {
1617     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1618     
1619     int m = 1;
1620     
1621     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1622     {
1623         for(unsigned int z = 0; z < this->get_depth(); z++)
1624         {
1625             for(unsigned int x = m; x < this->get_width()-m; x++)
1626             {
1627                 for(unsigned int y = m; y < this->get_height()-m; y++)
1628                 {
1629                     int sum = (get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1,y+1,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x-1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);
1630                     if (sum > 255 || sum < -255)
1631                     {
1632                         sum = 255;
1633                     }
1634                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1635                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1636                 }
1637                 
1638              }
1639              
1640          }
1641     }  
1642     
1643     return filtered;
1644     
1645 }
.fi
.SS "\fBImage\fP Image::filter_freeman_4 (intnum_threads)"

.PP
Applies the freeman mask $(-1,-1,-1)(1,-2,1)(1,1,1)$\&. 
.PP
Definition at line 1650 of file image\&.cpp\&.
.PP
.nf
1651 {
1652     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1653     
1654     int m = 1;
1655     
1656     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1657     {
1658         for(unsigned int z = 0; z < this->get_depth(); z++)
1659         {
1660             for(unsigned int x = m; x < this->get_width()-m; x++)
1661             {
1662                 for(unsigned int y = m; y < this->get_height()-m; y++)
1663                 {
1664                     int sum = (get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c))-1*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);
1665                     if (sum > 255 || sum < -255)
1666                     {
1667                         sum = 255;
1668                     }
1669                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1670                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1671                 }
1672                 
1673              }
1674              
1675          }
1676     }  
1677     
1678     return filtered;
1679     
1680 }
.fi
.SS "\fBImage\fP Image::filter_freeman_5 (intnum_threads)"

.PP
Applies the freeman mask $(1,-1,-1)(1,-2,-1)(1,1,1)$\&. 
.PP
Definition at line 1686 of file image\&.cpp\&.
.PP
.nf
1687 {
1688     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1689     
1690     int m = 1;
1691     
1692     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1693     {
1694         for(unsigned int z = 0; z < this->get_depth(); z++)
1695         {
1696             for(unsigned int x = m; x < this->get_width()-m; x++)
1697             {
1698                 for(unsigned int y = m; y < this->get_height()-m; y++)
1699                 {
1700                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c))-1*(get_pixel_value(x+1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);
1701                     if (sum > 255 || sum < -255)
1702                     {
1703                         sum = 255;
1704                     }
1705                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1706                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1707                 }
1708                 
1709              }
1710              
1711          }
1712     }  
1713     
1714     return filtered;
1715     
1716 }
.fi
.SS "\fBImage\fP Image::filter_freeman_6 (intnum_threads)"

.PP
Applies the freeman mask $(1,1,-1)(1,-2,-1)(1,1,-1)$\&. 
.PP
Definition at line 1722 of file image\&.cpp\&.
.PP
.nf
1723 {
1724     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1725     
1726     int m = 1;
1727     
1728     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1729     {
1730         for(unsigned int z = 0; z < this->get_depth(); z++)
1731         {
1732             for(unsigned int x = m; x < this->get_width()-m; x++)
1733             {
1734                 for(unsigned int y = m; y < this->get_height()-m; y++)
1735                 {
1736                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x, y-1, z, c))-1*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1,y+1,z,c))+-2*get_pixel_value(x, y, z, c);
1737                     if (sum > 255 || sum < -255)
1738                     {
1739                         sum = 255;
1740                     }
1741                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1742                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1743                 }
1744                 
1745              }
1746              
1747          }
1748     }  
1749     
1750     return filtered;
1751     
1752 }
.fi
.SS "\fBImage\fP Image::filter_freeman_7 (intnum_threads)"

.PP
Applies the freeman mask $(1,1,1)(1,-2,-1)(1,-1,-1)$\&. 
.PP
Definition at line 1757 of file image\&.cpp\&.
.PP
.nf
1758 {
1759     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1760     
1761     int m = 1;
1762     
1763     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1764     {
1765         for(unsigned int z = 0; z < this->get_depth(); z++)
1766         {
1767             for(unsigned int x = m; x < this->get_width()-m; x++)
1768             {
1769                 for(unsigned int y = m; y < this->get_height()-m; y++)
1770                 {
1771                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x, y-1, z, c))-1*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1,y+1,z,c))+-2*get_pixel_value(x, y, z, c);
1772                     if (sum > 255 || sum < -255)
1773                     {
1774                         sum = 255;
1775                     }
1776                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1777                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1778                 }
1779                 
1780              }
1781              
1782          }
1783     }  
1784     
1785     return filtered;
1786     
1787 }
.fi
.SS "\fBImage\fP Image::filter_gaussian (into, intdim_kernel, intnum_threads)"

.PP
This function applies a gaussian kernel trough the hole image\&. 
.PP
\fBParameters:\fP
.RS 4
\fIReceives\fP the dimension of the kernel (dim_kernel) and a paremeter o wich stablish the values on the gaussian kernel\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP filtered which is the image with the gaussian filter applied\&. 
.RE
.PP

.PP
Definition at line 841 of file image\&.cpp\&.
.PP
.nf
842 {
843     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);
844 
845     double kernel[dim_kernel*dim_kernel];
846     
847     int m = (dim_kernel-1)/2;
848     
849     double gaussian =1/pow(3\&.1415*2*o*o,0\&.5);
850 
851     for(int i =-m; i <=m; i++)
852     {
853         for(int j =-m; j<=+m; j++)
854         {
855             double exp= -(i*i+j*j)*0\&.5/(o*o);
856             kernel[(i+m)*dim_kernel + (j+m)]=gaussian*pow(2\&.7,exp); 
857             
858         }
859     }
860     
861     
862     
863     for(unsigned int c = 0; c < this->get_spectrum(); c++)
864     {
865         for(unsigned int z = 0; z < this->get_depth(); z++)
866         {
867             for(unsigned int x = m; x < this->get_width(); x++)
868             {
869                 for(unsigned int y = m; y < this->get_height(); y++)
870                 {
871                     int cont=0;
872                     unsigned char pixel=0;
873                     
874                     for(unsigned int i = x-m; i < x+m; i++)
875                     {
876                         for(unsigned int j = y-m; j< y+m; j++)
877                         {
878                             pixel+= this->get_pixel_value(i, j, z, c)*(kernel[cont]); 
879                             cont++;
880                         }
881                     }
882                     filtered\&.set_pixel_value(x, y, z, c, (pixel/2));
883                 }
884                 
885              }
886              
887          }
888     }  
889      return filtered;       
890 }   
.fi
.SS "\fBImage\fP Image::filter_Gradient_horizontal (intnum_threads)"
This filter is used as as Sharpening Spatial Filter, used to identify borders and noise in the image\&. Can be used to identify horizontal borders or discrepation Applies the following filter: $ ((1, 2, 1) , (0, 0, 0) , (-1, -2, -1)) $ 
.PP
\fBReturns:\fP
.RS 4
An image object that contains the original image after receiving a gradient filter in the horizontal direction\&. Could be used to identify horizontal borders\&. 
.RE
.PP

.PP
Definition at line 436 of file image\&.cpp\&.
.PP
.nf
437 {    
438     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
439     
440     int m = 1;
441     
442     for(unsigned int c = 0; c < this->get_spectrum(); c++)
443     {
444         for(unsigned int z = 0; z < this->get_depth(); z++)
445         {
446             for(unsigned int x = m; x < this->get_width()-m; x++)
447             {
448                 for(unsigned int y = m; y < this->get_height()-m; y++)
449                 {
450                     int sum = this->get_pixel_value(x-1, y-1, z, c) + 2*(this->get_pixel_value(x, y-1, z, c)) + this->get_pixel_value(x+1, y-1, z, c) - (this->get_pixel_value(x-1, y+1, z, c) + 2*(this->get_pixel_value(x, y+1, z, c)) + this->get_pixel_value(x+1, y+1, z, c));
451                     if (sum > 255 || sum < -255)
452                     {
453                         sum = 255;
454                     }
455                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
456                     filtered\&.set_pixel_value(x, y, z, c, pixel);
457                 }
458                 
459              }
460              
461          }
462     }  
463      return filtered;
464 }
.fi
.SS "\fBImage\fP Image::filter_Gradient_vertical (intnum_threads)"
This filter is used as as Sharpening Spatial Filter, used to identify borders and noise in the image\&. Can be used to identify vertical borders or discrepations\&. Applies the following filter: $ ((1, 0, -1) , (2, 0, -2) , (1, 0, -1)) $ 
.PP
\fBReturns:\fP
.RS 4
An image object that contains the original image after receiving a gradient filter in the vertical direction\&. Could be used to identify vertical borders\&. 
.RE
.PP

.PP
Definition at line 473 of file image\&.cpp\&.
.PP
.nf
474 {
475     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
476     
477     int m = 1;
478     
479     for(unsigned int c = 0; c < this->get_spectrum(); c++)
480     {
481         for(unsigned int z = 0; z < this->get_depth(); z++)
482         {
483             for(unsigned int x = m; x < this->get_width()-m; x++)
484             {
485                 for(unsigned int y = m; y < this->get_height()-m; y++)
486                 {
487                     int sum = get_pixel_value(x-1, y-1, z, c) + 2*get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) - (get_pixel_value(x+1, y-1, z, c) + 2*get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c));
488                     if (sum > 255 || sum < -255)
489                     {
490                         sum = 255;
491                     }
492                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
493                     filtered\&.set_pixel_value(x, y, z, c, pixel);
494                 }
495                 
496              }
497              
498          }
499     }  
500      return filtered;
501 }
.fi
.SS "\fBImage\fP Image::filter_horizontal_borders (intnum_threads)"

.PP
Definition at line 711 of file image\&.cpp\&.
.PP
.nf
712 {
713     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
714     
715     int m = 1;
716     
717     for(unsigned int c = 0; c < this->get_spectrum(); c++)
718     {
719         for(unsigned int z = 0; z < this->get_depth(); z++)
720         {
721             for(unsigned int x = 0; x < this->get_width()-m; x++)
722             {
723                 for(unsigned int y = m; y < this->get_height()-m; y++)
724                 {
725                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(this->get_pixel_value(x, y-1, z, c) - get_pixel_value(x, y+1, z, c)));
726                     filtered\&.set_pixel_value(x, y, z, c, pixel);
727                 }
728                 
729              }
730              
731          }
732     }  
733      return filtered;
734 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_0 (intnum_threads)"

.PP
Applies the kirsch mask at 0°\&. $(-3,-3,5)(-3,0,5)(-3,-3,5)$\&. 
.PP
Definition at line 1228 of file image\&.cpp\&.
.PP
.nf
1229 {
1230     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1231     
1232     int m = 1;
1233     
1234     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1235     {
1236         for(unsigned int z = 0; z < this->get_depth(); z++)
1237         {
1238             for(unsigned int x = m; x < this->get_width()-m; x++)
1239             {
1240                 for(unsigned int y = m; y < this->get_height()-m; y++)
1241                 {
1242                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c));
1243                     if (sum > 255 || sum < -255)
1244                     {
1245                         sum = 255;
1246                     }
1247                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1248                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1249                 }
1250                 
1251              }
1252              
1253          }
1254     }  
1255     
1256     return filtered;
1257     
1258 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_135 (intnum_threads)"

.PP
Applies the kirsch mask at 135°\&. $(5,5,-3)(5,0,-3)(-3,-3,-3)$\&. 
.PP
Definition at line 1335 of file image\&.cpp\&.
.PP
.nf
1336 {
1337     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1338     int m = 1;
1339     
1340     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1341     {
1342         for(unsigned int z = 0; z < this->get_depth(); z++)
1343         {
1344             for(unsigned int x = m; x < this->get_width()-m; x++)
1345             {
1346                 for(unsigned int y = m; y < this->get_height()-m; y++)
1347                 {
1348                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c));
1349                     if (sum > 255 || sum < -255)
1350                     {
1351                         sum = 255;
1352                     }
1353                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1354                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1355                 }
1356                 
1357              }
1358              
1359          }
1360     }  
1361     
1362     return filtered;
1363     
1364 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_180 (intnum_threads)"

.PP
Applies the kirsch mask at 180°\&. $(5,-3,-3)(5,0,-3)(5,-3,-3)$\&. 
.PP
Definition at line 1370 of file image\&.cpp\&.
.PP
.nf
1371 {
1372     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1373     int m = 1;
1374     
1375     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1376     {
1377         for(unsigned int z = 0; z < this->get_depth(); z++)
1378         {
1379             for(unsigned int x = m; x < this->get_width()-m; x++)
1380             {
1381                 for(unsigned int y = m; y < this->get_height()-m; y++)
1382                 {
1383                     int sum = -3*(get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x-1, y-1, z, c));
1384                     if (sum > 255 || sum < -255)
1385                     {
1386                         sum = 255;
1387                     }
1388                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1389                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1390                 }
1391                 
1392              }
1393              
1394          }
1395     }  
1396     
1397     return filtered;
1398     
1399 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_225 (intnum_threads)"

.PP
Applies the kirsch mask at 225°\&. $(-3,-3,-3)(5,0,-3)(5,5,-3)$\&. 
.PP
Definition at line 1405 of file image\&.cpp\&.
.PP
.nf
1406 {
1407     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1408     int m = 1;
1409     
1410     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1411     {
1412         for(unsigned int z = 0; z < this->get_depth(); z++)
1413         {
1414             for(unsigned int x = m; x < this->get_width()-m; x++)
1415             {
1416                 for(unsigned int y = m; y < this->get_height()-m; y++)
1417                 {
1418                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c));
1419                     if (sum > 255 || sum < -255)
1420                     {
1421                         sum = 255;
1422                     }
1423                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1424                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1425                 }
1426                 
1427              }
1428              
1429          }
1430     }  
1431     
1432     return filtered;
1433     
1434 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_270 (intnum_threads)"

.PP
Applies the kirsch mask at 270°\&. $(-3,-3,-3)(-3,0,-3)(5,5,5)$\&. 
.PP
Definition at line 1440 of file image\&.cpp\&.
.PP
.nf
1441 {
1442     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1443     int m = 1;
1444     
1445     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1446     {
1447         for(unsigned int z = 0; z < this->get_depth(); z++)
1448         {
1449             for(unsigned int x = m; x < this->get_width()-m; x++)
1450             {
1451                 for(unsigned int y = m; y < this->get_height()-m; y++)
1452                 {
1453                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c))+5*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x-1, y+1, z, c));
1454                     if (sum > 255 || sum < -255)
1455                     {
1456                         sum = 255;
1457                     }
1458                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1459                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1460                 }
1461                 
1462              }
1463              
1464          }
1465     }  
1466     
1467     return filtered;
1468     
1469 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_315 (intnum_threads)"

.PP
Applies the kirsch mask at 315°\&. $(-3,-3,-3)(-3,0,5)(-3,5,5)$\&. 
.PP
Definition at line 1475 of file image\&.cpp\&.
.PP
.nf
1476 {
1477     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1478     int m = 1;
1479     
1480     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1481     {
1482         for(unsigned int z = 0; z < this->get_depth(); z++)
1483         {
1484             for(unsigned int x = m; x < this->get_width()-m; x++)
1485             {
1486                 for(unsigned int y = m; y < this->get_height()-m; y++)
1487                 {
1488                     int sum = -3*(get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c))+5*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c));
1489                     if (sum > 255 || sum < -255)
1490                     {
1491                         sum = 255;
1492                     }
1493                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1494                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1495                 }
1496                 
1497              }
1498              
1499          }
1500     }  
1501     
1502     return filtered;
1503     
1504 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_45 (intnum_threads)"

.PP
Applies the kirsch mask at 45°\&. $(-3,5,5)(-3,0,5)(-3,-3,-3)$\&. 
.PP
Definition at line 1264 of file image\&.cpp\&.
.PP
.nf
1265 {
1266     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1267     int m = 1;
1268     
1269     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1270     {
1271         for(unsigned int z = 0; z < this->get_depth(); z++)
1272         {
1273             for(unsigned int x = m; x < this->get_width()-m; x++)
1274             {
1275                 for(unsigned int y = m; y < this->get_height()-m; y++)
1276                 {
1277                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x, y-1, z, c));
1278                     if (sum > 255 || sum < -255)
1279                     {
1280                         sum = 255;
1281                     }
1282                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1283                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1284                 }
1285                 
1286              }
1287              
1288          }
1289     }  
1290     
1291     return filtered;
1292     
1293     
1294 }
.fi
.SS "\fBImage\fP Image::filter_kirsch_90 (intnum_threads)"

.PP
Applies the kirsch mask at 90°\&. $(5,5,5)(-3,0-3)(-3,-3,-3)$\&. 
.PP
Definition at line 1300 of file image\&.cpp\&.
.PP
.nf
1301 {
1302     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1303     int m = 1;
1304     
1305     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1306     {
1307         for(unsigned int z = 0; z < this->get_depth(); z++)
1308         {
1309             for(unsigned int x = m; x < this->get_width()-m; x++)
1310             {
1311                 for(unsigned int y = m; y < this->get_height()-m; y++)
1312                 {
1313                     int sum = -3*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x-1, y-1, z, c));
1314                     if (sum > 255 || sum < -255)
1315                     {
1316                         sum = 255;
1317                     }
1318                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
1319                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1320                 }
1321                 
1322              }
1323              
1324          }
1325     }  
1326     
1327     return filtered;
1328     
1329 }
.fi
.SS "\fBImage\fP Image::filter_Laplacian (intnum_threads)"

.PP
Returns an image after applying the Laplacian filter to the image\&. Considers the diagonal values This function applies a convolution with this kernel: $ ((1, 1, 1), (1, -8, 1), (1, 1, 1)) $\&. 
.PP
\fBReturns:\fP
.RS 4
A Filtered image with the Laplacian filter applied\&. 
.RE
.PP

.PP
Definition at line 347 of file image\&.cpp\&.
.PP
.nf
348 {
349     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
350     
351     int m = 1;
352     
353     for(unsigned int c = 0; c < this->get_spectrum(); c++)
354     {
355         for(unsigned int z = 0; z < this->get_depth(); z++)
356         {
357             for(unsigned int x = m; x < this->get_width()-m; x++)
358             {
359                 for(unsigned int y = m; y < this->get_height()-m; y++)
360                 {
361                     int sum = 0;
362                     
363                     for (unsigned int i = 0 ; i < 3; i++)
364                     {
365                         for(unsigned int j = 0 ; j < 3; j++)
366                         {
367                         sum += -this->get_pixel_value(x+i-1, y+i-1, z, c);
368                         }
369                     }
370                     
371                     sum += 9*(this->get_pixel_value(x,y,z,c));
372                     
373                     if (sum > 255 || sum < -255)
374                     {
375                         sum = 255;
376                     }
377                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
378                     filtered\&.set_pixel_value(x, y, z, c, pixel);
379                 }
380                 
381              }
382              
383          }
384     }  
385     return filtered; 
386 }
.fi
.SS "\fBImage\fP Image::filter_Laplacian_no_diagonal (intnum_threads)"
Works as a derivative function, reacts to high change on the pixels value, especially to noise, and borders\&. Applies the following filter: $ ((0, -1, 0) , (-1, 4, -1) , (0, -1, 0)) $ 
.PP
\fBReturns:\fP
.RS 4
A filtered \fBImage\fP with the laplacian filter\&. 
.RE
.PP

.PP
Definition at line 393 of file image\&.cpp\&.
.PP
.nf
394 {
395     //int kernel[9] = {0, -1, 0, -1, 4, -1, 0, -1, 0};
396     
397     //return (this->filter(kernel, 3, 1));
398     
399     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
400     
401     int m = 1;
402     
403     for(unsigned int c = 0; c < this->get_spectrum(); c++)
404     {
405         for(unsigned int z = 0; z < this->get_depth(); z++)
406         {
407             for(unsigned int x = m; x < this->get_width()-m; x++)
408             {
409                 for(unsigned int y = m; y < this->get_height()-m; y++)
410                 {
411                     int sum = 4*(this->get_pixel_value(x,y,z,c)) - (this->get_pixel_value(x-1,y,z,c) + this->get_pixel_value(x+1,y,z,c) + this->get_pixel_value(x,y-1,z,c) +this->get_pixel_value(x,y+1,z,c));
412                     
413                     if (sum > 255 || sum < -255)
414                     {
415                         sum = 255;
416                     }
417                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
418                     filtered\&.set_pixel_value(x, y, z, c, pixel);
419                 }
420                 
421              }
422              
423          }
424     }  
425     return filtered; 
426     
427 }
.fi
.SS "\fBImage\fP Image::filter_maximum (intnum_threads)"

.PP
Assigns the highest value in the neighborhood\&. Assigns the highest value in the neighborhood around the desired pixel\&. 
.PP
Definition at line 1795 of file image\&.cpp\&.
.PP
.nf
1796 {
1797     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1798     
1799     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1800     {
1801         for(unsigned int z = 0; z < this->get_depth(); z++)
1802         {
1803             for(unsigned int x = 1; x < this->get_width()-1; x++)
1804             {
1805                 for(unsigned int y = 1; y < this->get_height()-1; y++)
1806                 {
1807                     unsigned char max = 0;
1808                     
1809                     for (unsigned int i = x-1; i< x+2; i++)
1810                     {
1811                         for (unsigned int j = y-1; j< y+2; j++)
1812                         {
1813                             unsigned char pixel = (this->get_pixel_value(i, j, z, c));
1814                              
1815                             if (pixel > max)
1816                             {
1817                                 max = this->get_pixel_value(i, j, z, c);
1818                             }
1819                         } 
1820                     }
1821                     
1822                     filtered\&.set_pixel_value(x, y, z, c, max);
1823                 }
1824                 
1825              }
1826              
1827          }
1828     }  
1829     return filtered;
1830 }
.fi
.SS "\fBImage\fP Image::filter_median (intdim, intnum_threads)"

.PP
This function calculates the median of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIOnly\fP receives the dimension of the kernel (dim), wich only can be an impair number\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP filtered which is the image with the median filter applied\&. 
.RE
.PP

.PP
Definition at line 747 of file image\&.cpp\&.
.PP
.nf
748 {
749     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
750     
751     //int kernel [dim*dim];
752 
753     int m = (dim-1)/2;
754     unsigned char pixel_values [dim*dim];
755     unsigned char temp;
756     
757     for(unsigned int c = 0; c < this->get_spectrum(); c++)
758     {
759         for(unsigned int z = 0; z < this->get_depth(); z++)
760         {
761             for(unsigned int x = m; x < this->get_width(); x++)
762             {
763                 for(unsigned int y = m; y < this->get_height(); y++)
764                 {
765                     for(unsigned int i = x-m; i < x+m; i++)
766                     {
767                         for(unsigned int j = y-m; j< y+m; j++)
768                         {
769                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);
770                             
771                         }   
772                     }
773                     for(int k=0; k<dim*dim ; k++)
774                     {
775                         for(int p=k+1 ; p<dim*dim ; p++)
776                         {
777                             if(pixel_values[p] < pixel_values[k])
778                             {
779                             // Intercambiar los valores
780                             temp = pixel_values[k];
781                             pixel_values[k] = pixel_values[p];
782                             pixel_values[p] = temp;
783                             }
784                         }
785                     }                   
786                     unsigned char pixel = pixel_values[((dim*dim-1)/2)-1];
787                     filtered\&.set_pixel_value(x, y, z, c, pixel);
788                 }
789                 
790              }
791              
792          }
793     }  
794      return filtered;
795  }
.fi
.SS "\fBImage\fP Image::filter_minimum (intnum_threads)"

.PP
Assigns the highest value in the neighborhood\&. 
.PP
Definition at line 1838 of file image\&.cpp\&.
.PP
.nf
1839 {
1840     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1841     
1842     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1843     {
1844         for(unsigned int z = 0; z < this->get_depth(); z++)
1845         {
1846             for(unsigned int x = 1; x < this->get_width()-1; x++)
1847             {
1848                 for(unsigned int y = 1; y < this->get_height()-1; y++)
1849                 {
1850                     unsigned char minimun = 255;
1851                     
1852                     for (unsigned int i = x-1; i< x+2; i++)
1853                     {
1854                         for (unsigned int j = y-1; j< y+2; j++)
1855                         {
1856                             if ((this->get_pixel_value(i, j, z, c)) < minimun)
1857                             {
1858                                 minimun = this->get_pixel_value(i, j, z, c);
1859                             }
1860                         } 
1861                     }
1862                     
1863                     filtered\&.set_pixel_value(x, y, z, c, minimun);
1864                 }
1865                 
1866              }
1867              
1868          }
1869     }  
1870      return filtered;
1871 }
.fi
.SS "\fBImage\fP Image::filter_modal (intdim, intnum_threads)"

.PP
This function calculates the modal of the range of pixels into the kernel and sets this value in the central pixel of the kernel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIOnly\fP receives the dimension of the kernel (dim), wich only can be an impair number\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP filtered which is the image with the modal filter applied\&. 
.RE
.PP

.PP
Definition at line 898 of file image\&.cpp\&.
.PP
.nf
899 {
900     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);
901     unsigned char pixel_values[dim*dim];
902     unsigned char moda;
903     unsigned char average=0;
904     int m=(dim-1)/2;
905     unsigned char copy_pixels[dim*dim];
906 
907     for(unsigned int c = 0; c < this->get_spectrum(); c++)
908     {
909         for(unsigned int z = 0; z < this->get_depth(); z++)
910         {
911             for(unsigned int x = m; x < this->get_width(); x++)
912             {
913                 for(unsigned int y = m; y < this->get_height(); y++)
914                 {
915                     for(unsigned int i = x-m; i < x+m; i++)
916                     {
917                         for(unsigned int j = y-m; j< y+m; j++)
918                         {
919                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);
920         
921                             int frequency[dim*dim];
922                             moda=0; 
923                             
924                             for(int k=0;k<dim*dim;k++)
925                             {
926                                 copy_pixels[k]= pixel_values[k];
927                                 frequency[k]=0;
928                             }
929                             
930                             for(int p=0;p<dim*dim;p++)
931                             {
932                                 for(int q=p+1;q<dim*dim;q++)
933                                 {
934                                     if(copy_pixels[p]==pixel_values[q]){
935                                         frequency[p]++;
936                                 
937                                     }
938             
939                                 }
940     
941                             }
942 
943 
944 
945                             for(int s=0; s<dim*dim ; s++)
946                             {
947                                 for(int e=s+1 ; e<dim*dim ; e++)
948                                 {
949                                     if(frequency[e] < frequency[s])
950                                     {
951                                         moda = copy_pixels[s];
952                                         average=copy_pixels[s];
953                                     }
954                                 }
955                             }
956                             
957 
958                             if(moda==0)
959                             {
960                                 for(int k=0;k<dim*dim;k++)
961                                 {
962                                     moda += pixel_values[k];
963                                 }
964                             average=(moda/dim);
965                             }
966 
967 
968                         }   
969                     }
970                     
971                     filtered\&.set_pixel_value(x, y, z, c, average);
972                 }
973                 
974              }
975              
976          }
977     }
978 
979 return filtered;
980 
981 }
.fi
.SS "\fBImage\fP Image::filter_order_stadistics (intdim, intorder, intnum_threads)"

.PP
Definition at line 1873 of file image\&.cpp\&.
.PP
.nf
1874 {
1875     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1876     
1877     //int kernel [dim*dim];
1878     
1879     int m = (dim-1)/2;
1880     
1881     unsigned char pixel_values [dim*dim];
1882     unsigned char temp;
1883     
1884     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1885     {
1886         for(unsigned int z = 0; z < this->get_depth(); z++)
1887         {
1888             for(unsigned int x = m; x < this->get_width(); x++)
1889             {
1890                 for(unsigned int y = m; y < this->get_height(); y++)
1891                 {
1892                     for(unsigned int i = x-m; i < x+m+1; i++)
1893                     {
1894                         for(unsigned int j = y-m; j< y+m+1; j++)
1895                         {
1896                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);
1897                             
1898                         }   
1899                     }
1900                     for(int k=0; k<dim*dim ; k++)
1901                     {
1902                         for(int p=k+1 ; p<dim*dim ; p++)
1903                         {
1904                             if(pixel_values[p] < pixel_values[k])
1905                             {
1906                             // Intercambiar los valores
1907                             temp = pixel_values[k];
1908                             pixel_values[k] = pixel_values[p];
1909                             pixel_values[p] = temp;
1910                             }
1911                         }
1912                     }                   
1913                     unsigned char pixel = pixel_values[order];
1914                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1915                 }
1916                 
1917              }
1918              
1919          }
1920     }  
1921      return filtered;
1922 }
.fi
.SS "\fBImage\fP Image::filter_Prewitt_E_W (intnum_threads)"

.PP
Definition at line 590 of file image\&.cpp\&.
.PP
.nf
591 {
592     //int kernel[9] = {1, 0, -1, 1, 0, -1, 1, 0, -1};
593     
594     //return (this->filter(kernel, 3, 1));  
595     
596     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
597     
598     int m = 1;
599     
600     for(unsigned int c = 0; c < this->get_spectrum(); c++)
601     {
602         for(unsigned int z = 0; z < this->get_depth(); z++)
603         {
604             for(unsigned int x = m; x < this->get_width()-m; x++)
605             {
606                 for(unsigned int y = m; y < this->get_height()-m; y++)
607                 {
608                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) - (get_pixel_value(x+1, y-1, z, c) + get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c));
609                     if (sum > 255 || sum < -255)
610                     {
611                         sum = 255;
612                     }
613                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
614                     filtered\&.set_pixel_value(x, y, z, c, pixel);
615                 }
616                 
617              }
618              
619          }
620     }  
621     
622     return filtered;
623     
624 }
.fi
.SS "\fBImage\fP Image::filter_Prewitt_N_S (intnum_threads)"

.PP
Definition at line 520 of file image\&.cpp\&.
.PP
.nf
521 {
522     //int kernel[9] = {1, 1, 1, 0, 0, 0, -1, -1, -1};
523     
524     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
525     
526     int m = 1;
527     
528     for(unsigned int c = 0; c < this->get_spectrum(); c++)
529     {
530         for(unsigned int z = 0; z < this->get_depth(); z++)
531         {
532             for(unsigned int x = m; x < this->get_width()-m; x++)
533             {
534                 for(unsigned int y = m; y < this->get_height()-m; y++)
535                 {
536                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x, y-1, z, c) + get_pixel_value(x+1, y-1, z, c) - (get_pixel_value(x-1, y+1, z, c) + get_pixel_value(x, y+1, z, c) + get_pixel_value(x+1, y+1, z, c));
537                     if (sum > 255 || sum < -255)
538                     {
539                         sum = 255;
540                     }
541                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
542                     filtered\&.set_pixel_value(x, y, z, c, pixel);
543                 }
544                 
545              }
546              
547          }
548     }  
549     
550     return filtered;
551     
552 }
.fi
.SS "\fBImage\fP Image::filter_Prewitt_NE_SW (intnum_threads)"

.PP
Definition at line 554 of file image\&.cpp\&.
.PP
.nf
555 {
556     //int kernel[9] = {0, 1, 1, -1, 0, 1, -1, -1, 0};
557     
558     //return (this->filter(kernel, 3, 1));
559     
560     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
561     
562     int m = 1;
563     
564     for(unsigned int c = 0; c < this->get_spectrum(); c++)
565     {
566         for(unsigned int z = 0; z < this->get_depth(); z++)
567         {
568             for(unsigned int x = m; x < this->get_width()-m; x++)
569             {
570                 for(unsigned int y = m; y < this->get_height()-m; y++)
571                 {
572                     int sum = get_pixel_value(x, y-1, z, c) + get_pixel_value(x+1, y-1, z, c) + get_pixel_value(x+1, y, z, c) - (get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) + get_pixel_value(x, y+1, z, c));
573                     if (sum > 255 || sum < -255)
574                     {
575                         sum = 255;
576                     }
577                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
578                     filtered\&.set_pixel_value(x, y, z, c, pixel);
579                 }
580                 
581              }
582              
583          }
584     }  
585     
586     return filtered;
587     
588 }
.fi
.SS "\fBImage\fP Image::filter_Prewitt_NW_SE (intnum_threads)"

.PP
Definition at line 626 of file image\&.cpp\&.
.PP
.nf
627 {
628     //int kernel[9] = {-1, -1, 0, -1, 0, 1, 0, 1, 1};
629     
630     // (this->filter(kernel, 3, 1));    
631     
632     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
633     
634     int m = 1;
635     
636     for(unsigned int c = 0; c < this->get_spectrum(); c++)
637     {
638         for(unsigned int z = 0; z < this->get_depth(); z++)
639         {
640             for(unsigned int x = m; x < this->get_width()-m; x++)
641             {
642                 for(unsigned int y = m; y < this->get_height()-m; y++)
643                 {
644                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x-1, y, z, c) + get_pixel_value(x, y-1, z, c) - (get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c) + get_pixel_value(x, y+1, z, c));
645                     if (sum > 255 || sum < -255)
646                     {
647                         sum = 255;
648                     }
649                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));
650                     filtered\&.set_pixel_value(x, y, z, c, pixel);
651                 }
652                 
653              }
654              
655          }
656     }  
657     
658     return filtered;
659         
660 }
.fi
.SS "\fBImage\fP Image::filter_vertical_borders (intnum_threads)"

.PP
Definition at line 686 of file image\&.cpp\&.
.PP
.nf
687 {
688     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
689     
690     int m = 1;
691     
692     for(unsigned int c = 0; c < this->get_spectrum(); c++)
693     {
694         for(unsigned int z = 0; z < this->get_depth(); z++)
695         {
696             for(unsigned int x = m; x < this->get_width()-m; x++)
697             {
698                 for(unsigned int y = 0; y < this->get_height()-m; y++)
699                 {
700                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(this->get_pixel_value(x-1, y, z, c) - get_pixel_value(x+1, y, z, c)));
701                     filtered\&.set_pixel_value(x, y, z, c, pixel);
702                 }
703                 
704              }
705              
706          }
707     }  
708      return filtered;
709 }
.fi
.SS "void Image::gaussian_noise (doublevariance, intnum_threads)"

.PP
Converts an RGB image to gray scale\&. This function applies the gaussian noise to an image\&. The gaussian noise increases or decreases intensity to a pixel, depending of the variance\&.
.PP
\fBParameters:\fP
.RS 4
\fIvariance\fP this parameter is used to set the value of noise that is applied to the image\&. 
.RE
.PP

.PP
Definition at line 1970 of file image\&.cpp\&.
.PP
.nf
1971 {
1972     srand(1);
1973     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1974     {
1975         for(unsigned int z = 0; z < this->get_depth(); z++)
1976         {
1977             for(unsigned int x = 0; x < this->get_width(); x++)
1978             {
1979                 for(unsigned int y = 0; y < this->get_height(); y++)
1980                 {
1981                     double random= variance*(rand()-RAND_MAX/variance)/RAND_MAX;
1982                     unsigned char pixel= this->get_pixel_value(x,y,z,c) + random;
1983                     
1984                     if((pixel<255) & (pixel>0))
1985                     {
1986                         (*(this->Img))(x, y, z, c)= pixel;
1987                     }   
1988 
1989                 }
1990                 
1991                 
1992              }
1993              
1994          }
1995     }  
1996      
1997 }
.fi
.SS "int * Image::get_histogram (unsigned intc, unsigned intz)"
This function returns an array containing the values of the histogram points, in the desired channel and depth\&. An Histogram is measure of the frecquency of a intensity value in an image, and is often used as a parameter to improve the constrast and quality of the image\&. After observing the histogram ( see \fBplot_histogram()\fP ) you could ecualizate the image\&. 
.PP
Definition at line 1167 of file image\&.cpp\&.
.PP
.nf
1168 {
1169     int histogram [256];
1170     for(int i = 0; i<256; i++)
1171     {
1172     histogram[i] = 0;   
1173     }
1174     
1175     if (c < this->get_spectrum() && z < this->get_depth())
1176     {
1177         for(unsigned int x = 0; x < this->get_width(); x++)
1178         {
1179             for(unsigned int y = 0; y < this->get_height(); y++)
1180             {
1181                 unsigned char pixel_value = this->get_pixel_value(x,y,z,c);
1182                 (histogram[pixel_value])++;
1183             }
1184         }
1185     }
1186     
1187     int* histogram_pointer = histogram;
1188     
1189     return histogram_pointer;
1190 }
.fi
.SS "\fBImage\fP Image::gray_scale (intnum_threads)"

.PP
Assigns the lowest value in the neighborhood\&. This function converts an RGB image to one in gray scale\&. The library uses this conversion: f(x,y)= 0\&.11R+0\&.56G + 0\&.14B Where f is the intensity of the pixel on the gray scale and R,G and B the pixel values on the different channels\&.
.PP
\fBReturns:\fP
.RS 4
This function returns the mochromathic image\&. 
.RE
.PP

.PP
Definition at line 2136 of file image\&.cpp\&.
.PP
.nf
2137 {
2138     Image gray_image (this->get_width() , this->get_height(), this->get_depth(), 1, 0); 
2139 
2140 
2141     for(unsigned int z = 0; z < this->get_depth(); z++)
2142     {
2143         for(unsigned int x = 0; x < this->get_width(); x++)
2144         {
2145             for(unsigned int y = 0; y < this->get_height(); y++)
2146             {
2147             
2148                 unsigned char pixel_intensity = 0\&.56*this->get_pixel_value(x,y,z,1)+0\&.14*this->get_pixel_value(x,y,z,0)+0\&.11*this->get_pixel_value(x,y,z,2);
2149                 gray_image\&.set_pixel_value(x, y, z, 0, pixel_intensity);
2150                 
2151             }
2152              
2153          }
2154     }  
2155      return gray_image; 
2156 } 
.fi
.SS "int* Image::histogram_equalization (int *, const char *title)"

.SS "\fBImage\fP Image::interpolation (intnum_threads)"

.PP
This function doubles the size of the image and use the closer neighborhood interpolation\&. 
.PP
\fBReturns:\fP
.RS 4
This function returns the image interpolated\&. 
.RE
.PP

.PP
Definition at line 2005 of file image\&.cpp\&.
.PP
.nf
2006 {
2007     int i,j=0;
2008     Image result (2*this->get_width(),2*this->get_height(),this->get_depth(),this->get_spectrum(),0);
2009     for(unsigned int c = 0; c < this->get_spectrum(); c++)
2010     {
2011         for(unsigned int z = 0; z < this->get_depth(); z++)
2012         {
2013             for(unsigned int y = 0; y < this->get_width(); y++)
2014             {
2015                 for(unsigned int x = 0; x < this->get_height(); x++)
2016                 {
2017                     unsigned char pixel=this->get_pixel_value(x,y,z,c);
2018                     
2019                     result\&.set_pixel_value(x+i,y+j,z,c,pixel);
2020                     result\&.set_pixel_value(x+1+i,y+j,z,c,pixel);
2021                     result\&.set_pixel_value(x+i,y+1+j,z,c,pixel);
2022                     result\&.set_pixel_value(x+1+i,y+1+j,z,c,pixel);
2023                     i++;
2024                 }
2025                 i=0;
2026                 j++;
2027             }
2028             j=0;
2029         }
2030     }
2031     return result;
2032 }
.fi
.SS "\fBImage\fP Image::inverse (intnum_threads)"
Executes this transformation: $ v(x,y,z,c) = 255 - u(x,y,z,c) $ 
.PP
\fBReturns:\fP
.RS 4
An image object that contains the inverse of the original image, this means that every pixel value is substracted to 255\&. 
.RE
.PP

.PP
Definition at line 994 of file image\&.cpp\&.
.PP
.nf
995 {
996     Image inverted (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
997 
998     for(unsigned int c = 0; c < this->get_spectrum(); c++)
999     {
1000         for(unsigned int z = 0; z < this->get_depth(); z++)
1001         {
1002             for(unsigned int x = 0; x < this->get_width(); x++)
1003             {
1004                 for(unsigned int y = 0; y < this->get_height(); y++)
1005                 {
1006                     unsigned char pixel= static_cast<unsigned int>(255-this->get_pixel_value(x,y,z,c));
1007                     inverted\&.set_pixel_value(x,y,z,c,pixel);
1008                 }
1009             }
1010         }
1011     }
1012     return inverted;
1013 }
.fi
.SS "\fBImage\fP Image::log_transformation (intnum_threads)"
Executes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$ where v(x,y,z,c) is the transformed pixel, and u(x,y,z,c) is the original pixel\&. 
.PP
\fBReturns:\fP
.RS 4
An image object that contains the inverse of the original image, this means that every pixel value is substracted to 255\&. 
.RE
.PP

.PP
Definition at line 1020 of file image\&.cpp\&.
.PP
.nf
1021 {
1022     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1023 
1024     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1025     {
1026         for(unsigned int z = 0; z < this->get_depth(); z++)
1027         {
1028             for(unsigned int x = 0; x < this->get_width(); x++)
1029             {
1030                 for(unsigned int y = 0; y < this->get_height(); y++)
1031                 {
1032                     unsigned char pixel = static_cast<unsigned char>((255/log(256)) * log(1+this->get_pixel_value(x, y, z, c)));
1033                     
1034                     filtered\&.set_pixel_value(x,y,z,c, pixel);
1035                 }
1036             }
1037         }
1038     }
1039     return filtered;
1040 }
.fi
.SS "\fBImage\fP Image::median_omp (int, int)"

.SS "\fBImage\fP Image::multiply_img (doublemultiplier, intnum_threads)"

.PP
This function multiplies the pixel values by a factor\&. If the pixel value is higher than 255, adjust the pixel value to 255\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP multiplier is the factor that mutiplies all the pixel values\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP result: Is the result of multiply the image\&. 
.RE
.PP

.PP
Definition at line 273 of file image\&.cpp\&.
.PP
.nf
274 {
275     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);
276     for(unsigned int c = 0; c < this->get_spectrum(); c++)
277     {
278         for(unsigned int z = 0; z < this->get_depth(); z++)
279         {
280             for(unsigned int x = 0; x < this->get_width(); x++)
281             {
282                 for(unsigned int y = 0; y < this->get_height(); y++)
283                 {
284                     unsigned char pixel= static_cast<unsigned int>(abs(this->get_pixel_value(x,y,z,c)*multiplier));
285                     if (pixel >255)
286                         pixel = 255;
287                     result\&.set_pixel_value(x,y,z,c,pixel);
288                 }
289             }
290         }
291     }
292     return result;
293 }
.fi
.SS "void Image::plot_histogram (intlevels, const char *title)"

.PP
This function plot the histogram, using the CImg histogram function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevels\fP is the number of bars or columns that appear in the histogram\&. 
.br
\fItitle\fP is the title of the histogram\&. 
.RE
.PP

.PP
Definition at line 1197 of file image\&.cpp\&.
.PP
.nf
1198 {
1199     CImg<unsigned char> img = this->Img->histogram(levels);
1200     
1201     CImgDisplay main_display (*(this->Img), title);
1202     
1203     img\&.display_graph(main_display, 3, 1, "Pixel Intensity", 0, 0, "Frequency", 0, 0);
1204 }
.fi
.SS "void Image::plot_histogram_equalization (intlevels, const char *title)"

.PP
Definition at line 1211 of file image\&.cpp\&.
.PP
.nf
1212 {
1213     CImg<unsigned char> img = this->Img->equalize(levels);
1214     
1215     CImgDisplay main_display (*(this->Img), title);
1216     
1217     img\&.display_graph(main_display, 3, 1, "Pixel Intensity", 0, 0, "Frequency", 0, 0);
1218 }
.fi
.SS "\fBImage\fP Image::power_law_transformatiom (doubleexponent, intnum_threads)"

.PP
Executes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$\&. Applies a transformation given by the ecuation $ v(x,y) = c {u(x,y)}^{\gamma} $ where $ u(x,y) $ is the value of the non filtered image, and $ v(xy) $ is the intensity value in the filtered image\&. $ \gamma, c $ are constants\&. In this case $ \gamma $ is a parameter\&. 
.PP
\fBReturns:\fP
.RS 4
A filtered image with the power law transformation 
.RE
.PP

.PP
Definition at line 1091 of file image\&.cpp\&.
.PP
.nf
1092 {
1093     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
1094     
1095     double k = (pow(255, 1-exponent));
1096     
1097     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1098     {
1099         for(unsigned int z = 0; z < this->get_depth(); z++)
1100         {
1101             for(unsigned int x = 0; x < this->get_width(); x++)
1102             {
1103                 for(unsigned int y = 0; y < this->get_height(); y++)
1104                 {
1105                     double power_law = k * pow( (this->get_pixel_value(x,y,z,c)) , exponent);
1106                     unsigned char pixel = static_cast<unsigned char>(power_law);
1107                     filtered\&.set_pixel_value(x, y, z, c, pixel);
1108                 }
1109                 
1110              }
1111              
1112          }
1113     }  
1114     return filtered;
1115 }
.fi
.SS "\fBImage\fP Image::rgb_hsv ()"

.SS "void Image::salt_pepper (doubleintensity, intnum_threads)"

.PP
Put pepper (black pixels) and salt(white pixels) 
.PP
\fBParameters:\fP
.RS 4
\fIintensity\fP is used to compute the percentage of salt and pepper that is applied to the image\&. 
.RE
.PP

.PP
Definition at line 1933 of file image\&.cpp\&.
.PP
.nf
1934 {
1935     srand(1);
1936     double percentage = 1-(intensity/100);
1937     for(unsigned int c = 0; c < this->get_spectrum(); c++)
1938     {
1939         for(unsigned int z = 0; z < this->get_depth(); z++)
1940         {
1941             for(unsigned int x = 0; x < this->get_width(); x++)
1942             {
1943                 for(unsigned int y = 0; y < this->get_height(); y++)
1944                 {
1945                     double random= 2\&.0*(rand()-RAND_MAX/2\&.0)/RAND_MAX;
1946                     if(random > percentage)
1947                     {
1948                         (*(this->Img))(x, y, z, c)= 255;
1949                     }   
1950 
1951                     else if(random<-1*percentage)
1952                     {
1953                         (*(this->Img))(x, y, z, c)= 0;                  
1954                     }
1955                 }
1956                 
1957                 
1958              }
1959              
1960          }
1961     }  
1962      
1963 }
.fi
.SS "void Image::set_pixel_value (intx, inty, intz, intc, unsigned charvalue)"

.PP
Definition at line 139 of file image\&.cpp\&.
.PP
Referenced by binarize_img(), color_slicing(), coorrelogram(), coorrelogram_ZC(), filter_average(), filter_dynamic_range_dilatation(), filter_edge_enhacement_displacement(), filter_freeman_0(), filter_freeman_1(), filter_freeman_2(), filter_freeman_3(), filter_freeman_4(), filter_freeman_5(), filter_freeman_6(), filter_freeman_7(), filter_gaussian(), filter_Gradient_horizontal(), filter_Gradient_vertical(), filter_horizontal_borders(), filter_kirsch_0(), filter_kirsch_135(), filter_kirsch_180(), filter_kirsch_225(), filter_kirsch_270(), filter_kirsch_315(), filter_kirsch_45(), filter_kirsch_90(), filter_Laplacian(), filter_Laplacian_no_diagonal(), filter_maximum(), filter_median(), filter_minimum(), filter_modal(), filter_order_stadistics(), filter_Prewitt_E_W(), filter_Prewitt_N_S(), filter_Prewitt_NE_SW(), filter_Prewitt_NW_SE(), filter_vertical_borders(), gray_scale(), interpolation(), inverse(), log_transformation(), multiply_img(), power_law_transformatiom(), substract_img(), sum_img(), and variance()\&.
.PP
.nf
140 {
141     (*(this->Img))(x, y, z, c)= value;
142 }
.fi
.SS "\fBImage\fP Image::substract_img (\fBImage\fPimage2, intnum_threads)"

.PP
This function substracts the pixel values of two images, that can be used to see the differences between them\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fBImage\fP\fP image2: Is the image that will be substracted to the original image\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBImage\fP result: Is the result of the substraction of both images\&. 
.RE
.PP

.PP
Definition at line 207 of file image\&.cpp\&.
.PP
.nf
208 {
209     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
210 
211     if(this->get_width() == image2\&.get_width() && this->get_height() == image2\&.get_height() && this->get_depth() == image2\&.get_depth() && this->get_spectrum() == image2\&.get_spectrum())
212     {
213         for(unsigned int c = 0; c < this->get_spectrum(); c++)
214         {
215             for(unsigned int z = 0; z < this->get_depth(); z++)
216             {
217                 for(unsigned int x = 0; x < this->get_width(); x++)
218                 {
219                     for(unsigned int y = 0; y < this->get_height(); y++)
220                     {
221                         unsigned char pixel= static_cast<unsigned int>(abs(this->get_pixel_value(x,y,z,c)-image2\&.get_pixel_value(x,y,z,c)));
222     
223                         result\&.set_pixel_value(x,y,z,c,pixel);
224                     }
225                 }
226             }
227         }
228     }
229     return result;
230 }
.fi
.SS "\fBImage\fP Image::sum_img (\fBImage\fPimage2, intnum_threads)"

.PP
Definition at line 233 of file image\&.cpp\&.
.PP
.nf
234 {
235     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
236 
237     if(this->get_width() == image2\&.get_width() && this->get_height() == image2\&.get_height() && this->get_depth() == image2\&.get_depth() && this->get_spectrum() == image2\&.get_spectrum())
238     {
239         for(unsigned int c = 0; c < this->get_spectrum(); c++)
240         {
241             for(unsigned int z = 0; z < this->get_depth(); z++)
242             {
243                 for(unsigned int x = 0; x < this->get_width(); x++)
244                 {
245                     for(unsigned int y = 0; y < this->get_height(); y++)
246                     {
247                         unsigned char pixel;
248                         int sum = this->get_pixel_value(x,y,z,c)+image2\&.get_pixel_value(x,y,z,c);
249                         if (sum <= 255)
250                         {
251                             pixel = static_cast<unsigned int>(sum);
252                         }
253                         else
254                         {
255                             pixel = 255;
256                         }
257                         result\&.set_pixel_value(x,y,z,c,pixel);
258                     }
259                 }
260             }
261         }
262     }
263     return result;
264 }
.fi
.SS "\fBImage\fP Image::variance (intdim, intnum_threads)"

.PP
This function compute the variance of an image\&. The variance is gived by the summation of the average multiplied by the substraction of the average with the pixel value, squared\&. 
.PP
\fBReturns:\fP
.RS 4
This function returns the image interpolated\&. 
.RE
.PP

.PP
Definition at line 2084 of file image\&.cpp\&.
.PP
Referenced by gaussian_noise()\&.
.PP
.nf
2085 {
2086     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); 
2087     
2088     for(unsigned int c = 0; c < this->get_spectrum(); c++)
2089     {
2090         for(unsigned int z = 0; z < this->get_depth(); z++)
2091         {
2092             for(unsigned int x = dim; x < this->get_width()-dim; x++)
2093             {
2094                 for(unsigned int y = dim; y < this->get_height()-dim; y++)
2095                 {
2096                     int sum = 0;
2097                     double variance=0;
2098                     int kernel_values[(dim*2+1)*(dim*2+1)];
2099                     int cont=0;
2100 
2101                     for(unsigned int i = x-dim; i<= x+dim; i++)
2102                     {
2103                         for(unsigned int j = y-dim; j<= y+dim; j++)
2104                         {
2105                             sum += this->get_pixel_value(i, j, z, c);
2106                             kernel_values[cont]=this->get_pixel_value(i, j, z, c);
2107                             cont++;
2108                         }
2109                     }
2110             
2111                     double average =  sum/((dim*2+1)*(dim*2+1));
2112                     for(int i=0;i<(dim*2+1)*(dim*2+1);i++)
2113                     {
2114                         variance+=pow(kernel_values[i]-average,2)/((dim*2+1)*(dim*2+1));
2115                     }
2116                     
2117                     
2118                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (variance);
2119                     filtered\&.set_pixel_value(x, y, z, c, pixel);
2120                 }
2121                 
2122              }
2123              
2124          }
2125     }  
2126      return filtered;
2127 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ParallelPic from the source code\&.
