{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment ParallelPic  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}ParallelPic}
{\comment Generated byDoxgyen. }
{\creatim \yr2013\mo12\dy9\hr1\min36\sec14}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Image} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstraction of the image, contains a CImg object that defines the handling of the image })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /home/fish/Documents/ParallelPic/Proyecto/include/{\b ParallelPic.hh} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/fish/Documents/ParallelPic/Proyecto/src/{\b image.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/fish/Documents/ParallelPic/Proyecto/src/{\b ParallelPic.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Image Class Reference\par \pard\plain 
{\tc\tcl2 \v Image}
{\xe \v Image}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Image} class is the abstraction of the image, contains a CImg object that defines the handling of the image. }}\par
{
{\f2 #include <ParallelPic.hh>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor This constructor initializes the four dimension params at 0; The Img calls the constructor of CImg to create an empty image. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} (const char *const filename)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Image()} is the constructor of the image used when the image doesn't been be created. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} (const unsigned int width, const unsigned int height, const unsigned int depth, const unsigned int spectrum, int value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Image} (const char *const filename) this constructor is used when the image already exist's and is stored in. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Image} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b display} (const char *message)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_pixel_value} (int x, int y, int z, int c, unsigned char)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b substract_img} ({\b Image}, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function substracts the pixel values of two images, that can be used to see the differences between them. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b sum_img} ({\b Image}, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b multiply_img} (double, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function multiplies the pixel values by a factor. If the pixel value is higher than 255, adjust the pixel value to 255. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b binarize_img} (unsigned int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Laplacian} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an image after applying the Laplacian filter to the image. Considers the diagonal values This function applies a convolution with this kernel: $ ((1, 1, 1), (1, -8, 1), (1, 1, 1)) $. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Laplacian_no_diagonal} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Gradient_vertical} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Gradient_horizontal} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Prewitt_N_S} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Prewitt_NE_SW} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Prewitt_E_W} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_Prewitt_NW_SE} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_edge_enhacement_displacement} (unsigned int, unsigned int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_horizontal_borders} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_vertical_borders} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_median} (int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the median of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_average} (int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the average of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b average_omp} (int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_gaussian} (int, int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function applies a gaussian kernel trough the hole image. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_modal} (int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the modal of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b median_omp} (int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_dynamic_range_dilatation} (unsigned char, unsigned char, double, double, double, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All the pixel values are divided in 3 ranges, and each range suffer a diferent transformation. This function is used to transform the range of lower pixel values in medium values and the higher too, to smooth the image. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b inverse} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b log_transformation} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b power_law_transformatiom} (double exponent, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b color_slicing} (unsigned char[], unsigned char[], unsigned char[], int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Highlights the desired colors, between the two colors given as parameters. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b get_histogram} (unsigned int c, unsigned int z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plot_histogram} (int, const char *title)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function plot the histogram, using the CImg histogram function. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b histogram_equalization} (int *, const char *title)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CImg< float > {\b autocovariance} (int, int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the autocovariance matrix for the image. The covariance, calculates the covariance matrix of an image. This function calculates something similar to the function below: $ g(x,y) = \sum \limits_{n=0}^{N} \sum \limits_{m=1}^M \left( f(x,y) - \overline{f(x,y)}\right)\left(f(x + \Delta x, y + \Delta y) - \overline{f(x + \Delta x, y + \Delta y)} \right) $ Where it calculates the variation between two series, one is the normal one, and the other is displaced by two parameters $ x$ & $ y$. For an image it its calculated for a neighborhood around each pixel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plot_histogram_equalization} (int, const char *title)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_order_stadistics} (int dim, int order, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b variance} (int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function compute the variance of an image. The variance is gived by the summation of the average multiplied by the substraction of the average with the pixel value, squared. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_0} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 0\'B0. $(-3,-3,5)(-3,0,5)(-3,-3,5)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_45} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 45\'B0. $(-3,5,5)(-3,0,5)(-3,-3,-3)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_90} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 90\'B0. $(5,5,5)(-3,0-3)(-3,-3,-3)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_135} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 135\'B0. $(5,5,-3)(5,0,-3)(-3,-3,-3)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_180} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 180\'B0. $(5,-3,-3)(5,0,-3)(5,-3,-3)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_225} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 225\'B0. $(-3,-3,-3)(5,0,-3)(5,5,-3)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_270} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 270\'B0. $(-3,-3,-3)(-3,0,-3)(5,5,5)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_kirsch_315} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 315\'B0. $(-3,-3,-3)(-3,0,5)(-3,5,5)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_0} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(1,-2,1)(1,-1,-1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_1} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(-1,-2,1)(1,-1,1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_2} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $)-1,1,1)(-1,-2,1)(1,1,1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_3} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(-1,-1,1)(-1,-2,1)(1,1,1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_4} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(-1,-1,-1)(1,-2,1)(1,1,1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_5} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,-1,-1)(1,-2,-1)(1,1,1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_6} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,-1)(1,-2,-1)(1,1,-1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_freeman_7} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(1,-2,-1)(1,-1,-1)$. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_maximum} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the highest value in the neighborhood. Assigns the highest value in the neighborhood around the desired pixel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b filter_minimum} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the highest value in the neighborhood. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b gray_scale} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the lowest value in the neighborhood. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gaussian_noise} (double, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts an RGB image to gray scale. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b salt_pepper} (double, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put pepper (black pixels) and salt(white pixels) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b interpolation} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function doubles the size of the image and use the closer neighborhood interpolation. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b coorrelogram} (unsigned int, unsigned int, int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function compute the coorrelogram of an image. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b coorrelogram_ZC} (unsigned int, unsigned int, unsigned int, unsigned int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b coorrelogram_par} (unsigned int, unsigned int, unsigned int, unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Image} {\b rgb_hsv} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Image} class is the abstraction of the image, contains a CImg object that defines the handling of the image. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class have the attributes of the four dimensions of the image: height, width, depth and spectrum \par
}{
Definition at line 21 of file ParallelPic.hh.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Image\:Image}
{\xe \v Image\:Image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Image::Image ()}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor This constructor initializes the four dimension params at 0; The Img calls the constructor of CImg to create an empty image. }}\par
{
Definition at line 17 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     this->Img = new CImg<unsigned char>();\par
20     this->width = 0;\par
21     this->height = 0;\par
22     this->depth = 0;\par
23     this->spectrum = 0;\par
24 \par
25 \}\par
}
}
{\xe \v Image\:Image}
{\xe \v Image\:Image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Image::Image (const char *const {\i filename})}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Image()} is the constructor of the image used when the image doesn't been be created. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor.\par
This constructor is used when the image already exist's and is stored in the{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{path. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <Img>} \cell }{is a var of type Cimg that is treated like an unsigned char.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <width>} \cell }{refers to the number of columns of pixels in the image.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <height>} \cell }{refers to the number of rows of pixels in the image.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <depth>} \cell }{is the amount of layers of depth the image has, usually is one, except for 3D images.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <spectrum>} \cell }{is the number of channels in the image, RGB has a spectrum of 3, a monocromatic image has a spectrum of 1. \cell }
{\row }
}
}{
Definition at line 32 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 33 \{\par
34     this->Img = new CImg<unsigned char>(filename);\par
36     this->width = this->Img->width();\par
38     this->height = this->Img->height();\par
40     this->depth = this->Img->depth();\par
42     this->spectrum = this->Img->spectrum();\par
44 \}\par
}
}
{\xe \v Image\:Image}
{\xe \v Image\:Image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Image::Image (const unsigned int {\i width}, const unsigned int {\i height}, const unsigned int {\i depth}, const unsigned int {\i spectrum}, int {\i value})}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Image} (const char *const filename) this constructor is used when the image already exist's and is stored in. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used when we need to create an image, and gives the dimensions of the image, and the value of a color that fills all the pixels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename.} \cell }{\cell }
{\row }
}
}{
Definition at line 49 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50 \{\par
51     this->Img = new CImg<unsigned char>(width, height, depth, spectrum, value);\par
52     this->width = width;\par
53     this->height = height;\par
54     this->depth = depth;\par
55     this->spectrum = spectrum;\par
56 \}\par
}
}
{\xe \v ~Image\:Image}
{\xe \v Image\:~Image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Image::~Image (void )}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Image} (const unsigned int width, const unsigned int height, const unsigned int depth, const unsigned int spectrum, int value) This constructor is used when we try to create an image with the specified dimensions and the parameter{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{is the value of the color of all the pixels of the image. \cell }
{\row }
}
}{
Definition at line 60 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 61 \{\par
62     \par
63 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v autocovariance\:Image}
{\xe \v Image\:autocovariance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CImg< float > Image::autocovariance (int {\i hor_dis}, int {\i ver_dis}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the autocovariance matrix for the image. The covariance, calculates the covariance matrix of an image. This function calculates something similar to the function below: $ g(x,y) = \sum \limits_{n=0}^{N} \sum \limits_{m=1}^M \left( f(x,y) - \overline{f(x,y)}\right)\left(f(x + \Delta x, y + \Delta y) - \overline{f(x + \Delta x, y + \Delta y)} \right) $ Where it calculates the variation between two series, one is the normal one, and the other is displaced by two parameters $ x$ & $ y$. For an image it its calculated for a neighborhood around each pixel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A CImg object, because it must contain float values. \par
}}{
Definition at line 2047 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2048 \{\par
2049     CImg<float> autocovariance (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
2050     \par
2051     Image average = this->filter_average(1);\par
2052 \par
2053     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
2054     \{\par
2055         for(unsigned int z = 0; z < this->get_depth(); z++)\par
2056         \{\par
2057             for(unsigned int x = 3+hor_dis; x < this->get_width()-(3+hor_dis); x++)\par
2058             \{\par
2059                 for(unsigned int y = 3+ver_dis; y < this->get_height()-(3+ver_dis); y++)\par
2060                 \{\par
2061                     int sum = 0;\par
2062                     for(unsigned int i = x-3; i<x+4; i++)\par
2063                     \{\par
2064                         for(unsigned int j= y-3; j<y+4; j++)\par
2065                         \{\par
2066                             sum += ( (this->get_pixel_value(i,j,z,c))  -  average.get_pixel_value(i,j,z,c)) * ( (this->get_pixel_value(i+hor_dis,j+ver_dis,z,c))  -  average.get_pixel_value(i+hor_dis,j+ver_dis,z,c)) ;\par
2067                         \}\par
2068                     \}\par
2069                 \par
2070                     autocovariance(x,y,z,c) = sum/49;\par
2071                 \}\par
2072             \}\par
2073         \}\par
2074      \}\par
2075     return autocovariance;\par
2076 \}\par
}
}
{\xe \v average_omp\:Image}
{\xe \v Image\:average_omp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::average_omp (int , int )}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v binarize_img\:Image}
{\xe \v Image\:binarize_img}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::binarize_img (unsigned int {\i cutoff_value}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 302 \{\par
303     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);\par
304     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
305     \{\par
306         for(unsigned int z = 0; z < this->get_depth(); z++)\par
307         \{\par
308             for(unsigned int x = 0; x < this->get_width(); x++)\par
309             \{\par
310                 for(unsigned int y = 0; y < this->get_height(); y++)\par
311                 \{\par
312                     unsigned char pixel= static_cast<unsigned int>(this->get_pixel_value(x,y,z,c));\par
313                     if(pixel >= cutoff_value)\par
314                         pixel=255;\par
315                     else\par
316                         pixel=0;\par
317                     result.set_pixel_value(x,y,z,c,pixel);\par
318 \par
319                 \}\par
320             \}\par
321         \}\par
322     \}\par
323 \par
324     \par
325     return result;\par
326 \}\par
}
}
{\xe \v color_slicing\:Image}
{\xe \v Image\:color_slicing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::color_slicing (unsigned char {\i color1}[], unsigned char {\i color2}[], unsigned char {\i neutral}[], int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Highlights the desired colors, between the two colors given as parameters. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Attention:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \{The colors must be unsigned char, and must be the size of the spectrum of the image (Number of channels), 3 in case o RBG images\} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{char color1[]: The start color of the color slicing. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{char color2[]: The end color of the color slicing. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{char neutral: The intensity every other pixels that are not between the given colors will be set to. \cell }
{\row }
}
}{
Definition at line 1124 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1125 \{\par
1126     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1127     \par
1128     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1129     \{\par
1130         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1131         \{\par
1132             for(unsigned int x = 0; x < this->get_width(); x++)\par
1133             \{\par
1134                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1135                 \{\par
1136                     unsigned char pixel = this->get_pixel_value(x,y,z,c);\par
1137                     if(pixel > color1[c] && pixel < color2[c] )\par
1138                     \{\par
1139                         filtered.set_pixel_value(x, y, z, c, pixel);\par
1140                     \}\par
1141                     else\par
1142                     \{\par
1143                         filtered.set_pixel_value(x,y,z,c, neutral[c]);\par
1144                     \}\par
1145                 \}\par
1146                 \par
1147              \}\par
1148              \par
1149          \}\par
1150     \}  \par
1151     \par
1152     return filtered;\par
1153     \par
1154 \}\par
}
}
{\xe \v coorrelogram\:Image}
{\xe \v Image\:coorrelogram}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::coorrelogram (unsigned int {\i ver}, unsigned int {\i hor}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function compute the coorrelogram of an image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function compute the coorrelogram of a specified depth and spectrum of an image.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int ver is the vertical distance of the original pixel that we use to compute the coorrelogram. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int hor is the horizontal distance of the original pixel that we use to compute the coorrelogram. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function returns the coorrelogram image.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int ver is the vertical distance of the original pixel that we use to compute the coorrelogram. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int hor is the horizontal distance of the original pixel that we use to compute the coorrelogram. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int z is the specified depth of the image that will be obtained the coorrelogram. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{int c is the specified spectrum of the image that will be obtained the coorrelogram. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function returns the coorrelogram image. \par
}}{
Definition at line 2164 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2165 \{\par
2166     \par
2167     Image result (256,256, 1, 1, 0);    \par
2168     \par
2169     for(unsigned int i = 0; i < 256; i++)\par
2170     \{\par
2171         for(unsigned int j=0; j< 256; j++)\par
2172         \{\par
2173             unsigned int pixel = 0;\par
2174             \par
2175             for(unsigned int x=0; x< (this->get_width()-hor);++x)\par
2176             \{\par
2177                 \par
2178                 for(unsigned int y=0; y< (this->get_height()-ver);++y)\par
2179                 \{\par
2180                     unsigned char first = (this->get_pixel_value(x,y,0,0));\par
2181                     unsigned char secnd = (this->get_pixel_value(x+hor, y+ver, 0, 0));\par
2182                     \par
2183                     if(first == i && secnd == j)\par
2184                     \{\par
2185                         pixel ++;\par
2186                     \}\par
2187                 \}\par
2188             \}\par
2189             if(pixel>255)\par
2190             \{\par
2191                 pixel=255;\par
2192             \}\par
2193             \par
2194             result.set_pixel_value(i, j, 0, 0, pixel);\par
2195             \par
2196         \}\par
2197         \par
2198         cout<<"\\n"<<i<<"\\n"<<endl;  \par
2199     \}\par
2200     return result;\par
2201 \par
2202 \}\par
}
}
{\xe \v coorrelogram_par\:Image}
{\xe \v Image\:coorrelogram_par}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::coorrelogram_par (unsigned {\i int}, unsigned {\i int}, unsigned {\i int}, unsigned {\i int})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v coorrelogram_ZC\:Image}
{\xe \v Image\:coorrelogram_ZC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::coorrelogram_ZC (unsigned int {\i ver}, unsigned int {\i hor}, unsigned int {\i z}, unsigned int {\i c}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2212 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2213 \{\par
2214     \par
2215     Image result (256,256, 1, 1, 0);    \par
2216     \par
2217     for(unsigned int i = 0; i < 256; i++)\par
2218     \{\par
2219         for(unsigned int j=0; j< 256; j++)\par
2220         \{\par
2221             unsigned int pixel = 0;\par
2222             \par
2223             for(unsigned int x=0; x< (this->get_width()-hor);++x)\par
2224             \{\par
2225                 \par
2226                 for(unsigned int y=0; y< (this->get_height()-ver);++y)\par
2227                 \{\par
2228                     unsigned char first = (this->get_pixel_value(x,y,z,c));\par
2229                     unsigned char secnd = (this->get_pixel_value(x+hor, y+ver, z, c));\par
2230                     if(first == i && secnd == j)\par
2231                     \{\par
2232                         pixel ++;\par
2233                     \}\par
2234                 \}\par
2235             \}\par
2236             if(pixel>255)\par
2237             \{\par
2238                 pixel=255;\par
2239             \}\par
2240 \par
2241             result.set_pixel_value(i, j, 0, 0, pixel);\par
2242             \par
2243         \}\par
2244         \par
2245     \}\par
2246     return result;\par
2247 \par
2248 \}\par
}
}
{\xe \v display\:Image}
{\xe \v Image\:display}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::display (const char * {\i message})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 78 \{\par
79     CImgDisplay main (*(this->Img), message);\par
80     while(!main.is_closed())\par
81     \{\par
82         main.wait();\par
83     \}\par
84 \}\par
}
}
{\xe \v filter_average\:Image}
{\xe \v Image\:filter_average}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_average (int {\i dim}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the average of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Only} \cell }{receives the dimension of the kernel (dim), wich only can be an impair number. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} filtered which is the image with the average filter applied. \par
}}{
Definition at line 803 of file image.cpp.}\par
{
Referenced by autocovariance().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 804 \{\par
805     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
806 \par
807     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
808     \{\par
809         for(unsigned int z = 0; z < this->get_depth(); z++)\par
810         \{\par
811             for(unsigned int x = dim; x < this->get_width()-dim; x++)\par
812             \{\par
813                 for(unsigned int y = dim; y < this->get_height()-dim; y++)\par
814                 \{\par
815                     int sum = 0;\par
816                     for(unsigned int i = x-dim; i<= x+dim; i++)\par
817                     \{\par
818                         for(unsigned int j = y-dim; j<= y+dim; j++)\par
819                         \{\par
820                             sum += this->get_pixel_value(i, j, z, c);\par
821                         \}\par
822                     \}\par
823             \par
824                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (sum/((dim*2+1)*(dim*2+1)));\par
825                     filtered.set_pixel_value(x, y, z, c, pixel);\par
826                 \}\par
827                 \par
828              \}\par
829              \par
830          \}\par
831     \}  \par
832      return filtered;   \par
833 \} \par
}
}
{\xe \v filter_dynamic_range_dilatation\:Image}
{\xe \v Image\:filter_dynamic_range_dilatation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_dynamic_range_dilatation (unsigned char {\i a}, unsigned char {\i b}, double {\i alpha}, double {\i beta}, double {\i gamma}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All the pixel values are divided in 3 ranges, and each range suffer a diferent transformation. This function is used to transform the range of lower pixel values in medium values and the higher too, to smooth the image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{char a is the first cutoff pixel value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i unsigned} \cell }{char b is the second cutoff pixel value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{alpha is the first multiplier. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{beta is the second multiplier. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{gamma is the third multiplier. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An image object that contains the dilatated image. \par
}}{
Definition at line 1052 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1053 \{\par
1054     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1055     \par
1056     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1057     \{\par
1058         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1059         \{\par
1060             for(unsigned int x = 0; x < this->get_width(); x++)\par
1061             \{\par
1062                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1063                 \{\par
1064                     unsigned char pixel=0;\par
1065                     \par
1066                     if(this->get_pixel_value(x,y,z,c)<a)\par
1067                         pixel =abs(alpha*this->get_pixel_value(x,y,z,c));\par
1068                         \par
1069                     else if(this->get_pixel_value(x,y,z,c)>=a && this->get_pixel_value(x,y,z,c)<b)\par
1070                         pixel=abs(beta*(this->get_pixel_value(x,y,z,c)-a)+alpha*a);\par
1071                     \par
1072                     else if(this->get_pixel_value(x,y,z,c)<=b)\par
1073                         \par
1074                         pixel=abs(gamma*(this->get_pixel_value(x,y,z,c)-b)+((beta*(b-a))+alpha*a));\par
1075                     filtered.set_pixel_value(x,y,z,c,static_cast<unsigned int>(pixel));\par
1076                 \}\par
1077             \}\par
1078         \}\par
1079     \}\par
1080     return filtered;\par
1081 \}\par
}
}
{\xe \v filter_edge_enhacement_displacement\:Image}
{\xe \v Image\:filter_edge_enhacement_displacement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_edge_enhacement_displacement (unsigned int {\i horizontal_dis}, unsigned int {\i vertical_dis}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 662 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 663 \{\par
664     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
665     if((horizontal_dis < this->get_width()) && (vertical_dis < this->get_height()))\par
666     \{\par
667         for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
668         \{\par
669             for(unsigned int z = 0; z < this->get_depth(); z++)\par
670             \{\par
671                 for(unsigned int x = horizontal_dis; x < this->get_width(); x++)\par
672                 \{\par
673                     for(unsigned int y = vertical_dis; y < this->get_height(); y++)\par
674                     \{\par
675                         unsigned char value = static_cast<unsigned char>(abs(this->get_pixel_value(x,y,z,c) - this->get_pixel_value(x-horizontal_dis, y-vertical_dis, z, c)));\par
676                         \par
677                         result.set_pixel_value(x,y,z,c, value);\par
678                     \}\par
679                 \}\par
680             \}\par
681         \}\par
682     \}\par
683     return result;\par
684 \}\par
}
}
{\xe \v filter_freeman_0\:Image}
{\xe \v Image\:filter_freeman_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_0 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(1,-2,1)(1,-1,-1)$. }}\par
{
Definition at line 1510 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1511 \{\par
1512     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1513     \par
1514     int m = 1;\par
1515     \par
1516     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1517     \{\par
1518         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1519         \{\par
1520             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1521             \{\par
1522                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1523                 \{\par
1524                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1,y,z,c))-1*(get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+-2*get_pixel_value(x, y, z, c);\par
1525                     if (sum > 255 || sum < -255)\par
1526                     \{\par
1527                         sum = 255;\par
1528                     \}\par
1529                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1530                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1531                 \}\par
1532                 \par
1533              \}\par
1534              \par
1535          \}\par
1536     \}  \par
1537     \par
1538     return filtered;\par
1539     \par
1540 \}\par
}
}
{\xe \v filter_freeman_1\:Image}
{\xe \v Image\:filter_freeman_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_1 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(-1,-2,1)(1,-1,1)$. }}\par
{
Definition at line 1545 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1546 \{\par
1547     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1548     \par
1549     int m = 1;\par
1550     \par
1551     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1552     \{\par
1553         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1554         \{\par
1555             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1556             \{\par
1557                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1558                 \{\par
1559                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1,y,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y+1, z, c))+-2*get_pixel_value(x, y, z, c);\par
1560                     if (sum > 255 || sum < -255)\par
1561                     \{\par
1562                         sum = 255;\par
1563                     \}\par
1564                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1565                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1566                 \}\par
1567                 \par
1568              \}\par
1569              \par
1570          \}\par
1571     \}  \par
1572     \par
1573     return filtered;\par
1574     \par
1575 \}\par
}
}
{\xe \v filter_freeman_2\:Image}
{\xe \v Image\:filter_freeman_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_2 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $)-1,1,1)(-1,-2,1)(1,1,1)$. }}\par
{
Definition at line 1580 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1581 \{\par
1582     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1583     \par
1584     int m = 1;\par
1585     \par
1586     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1587     \{\par
1588         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1589         \{\par
1590             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1591             \{\par
1592                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1593                 \{\par
1594                     int sum = (get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1,y+1,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c))+-2*get_pixel_value(x, y, z, c);\par
1595                     if (sum > 255 || sum < -255)\par
1596                     \{\par
1597                         sum = 255;\par
1598                     \}\par
1599                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1600                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1601                 \}\par
1602                 \par
1603              \}\par
1604              \par
1605          \}\par
1606     \}  \par
1607     \par
1608     return filtered;\par
1609     \par
1610 \}\par
}
}
{\xe \v filter_freeman_3\:Image}
{\xe \v Image\:filter_freeman_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_3 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(-1,-1,1)(-1,-2,1)(1,1,1)$. }}\par
{
Definition at line 1615 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1616 \{\par
1617     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1618     \par
1619     int m = 1;\par
1620     \par
1621     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1622     \{\par
1623         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1624         \{\par
1625             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1626             \{\par
1627                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1628                 \{\par
1629                     int sum = (get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1,y+1,z,c))-1*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x-1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);\par
1630                     if (sum > 255 || sum < -255)\par
1631                     \{\par
1632                         sum = 255;\par
1633                     \}\par
1634                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1635                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1636                 \}\par
1637                 \par
1638              \}\par
1639              \par
1640          \}\par
1641     \}  \par
1642     \par
1643     return filtered;\par
1644     \par
1645 \}\par
}
}
{\xe \v filter_freeman_4\:Image}
{\xe \v Image\:filter_freeman_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_4 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(-1,-1,-1)(1,-2,1)(1,1,1)$. }}\par
{
Definition at line 1650 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1651 \{\par
1652     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1653     \par
1654     int m = 1;\par
1655     \par
1656     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1657     \{\par
1658         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1659         \{\par
1660             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1661             \{\par
1662                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1663                 \{\par
1664                     int sum = (get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c))-1*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);\par
1665                     if (sum > 255 || sum < -255)\par
1666                     \{\par
1667                         sum = 255;\par
1668                     \}\par
1669                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1670                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1671                 \}\par
1672                 \par
1673              \}\par
1674              \par
1675          \}\par
1676     \}  \par
1677     \par
1678     return filtered;\par
1679     \par
1680 \}\par
}
}
{\xe \v filter_freeman_5\:Image}
{\xe \v Image\:filter_freeman_5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_5 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,-1,-1)(1,-2,-1)(1,1,1)$. }}\par
{
Definition at line 1686 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1687 \{\par
1688     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1689     \par
1690     int m = 1;\par
1691     \par
1692     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1693     \{\par
1694         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1695         \{\par
1696             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1697             \{\par
1698                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1699                 \{\par
1700                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c))-1*(get_pixel_value(x+1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1,y-1,z,c))+-2*get_pixel_value(x, y, z, c);\par
1701                     if (sum > 255 || sum < -255)\par
1702                     \{\par
1703                         sum = 255;\par
1704                     \}\par
1705                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1706                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1707                 \}\par
1708                 \par
1709              \}\par
1710              \par
1711          \}\par
1712     \}  \par
1713     \par
1714     return filtered;\par
1715     \par
1716 \}\par
}
}
{\xe \v filter_freeman_6\:Image}
{\xe \v Image\:filter_freeman_6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_6 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,-1)(1,-2,-1)(1,1,-1)$. }}\par
{
Definition at line 1722 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1723 \{\par
1724     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1725     \par
1726     int m = 1;\par
1727     \par
1728     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1729     \{\par
1730         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1731         \{\par
1732             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1733             \{\par
1734                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1735                 \{\par
1736                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x, y-1, z, c))-1*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1,y+1,z,c))+-2*get_pixel_value(x, y, z, c);\par
1737                     if (sum > 255 || sum < -255)\par
1738                     \{\par
1739                         sum = 255;\par
1740                     \}\par
1741                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1742                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1743                 \}\par
1744                 \par
1745              \}\par
1746              \par
1747          \}\par
1748     \}  \par
1749     \par
1750     return filtered;\par
1751     \par
1752 \}\par
}
}
{\xe \v filter_freeman_7\:Image}
{\xe \v Image\:filter_freeman_7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_freeman_7 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the freeman mask $(1,1,1)(1,-2,-1)(1,-1,-1)$. }}\par
{
Definition at line 1757 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1758 \{\par
1759     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1760     \par
1761     int m = 1;\par
1762     \par
1763     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1764     \{\par
1765         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1766         \{\par
1767             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1768             \{\par
1769                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1770                 \{\par
1771                     int sum = (get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x, y-1, z, c))-1*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1,y+1,z,c))+-2*get_pixel_value(x, y, z, c);\par
1772                     if (sum > 255 || sum < -255)\par
1773                     \{\par
1774                         sum = 255;\par
1775                     \}\par
1776                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1777                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1778                 \}\par
1779                 \par
1780              \}\par
1781              \par
1782          \}\par
1783     \}  \par
1784     \par
1785     return filtered;\par
1786     \par
1787 \}\par
}
}
{\xe \v filter_gaussian\:Image}
{\xe \v Image\:filter_gaussian}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_gaussian (int {\i o}, int {\i dim_kernel}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function applies a gaussian kernel trough the hole image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Receives} \cell }{the dimension of the kernel (dim_kernel) and a paremeter o wich stablish the values on the gaussian kernel. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} filtered which is the image with the gaussian filter applied. \par
}}{
Definition at line 841 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 842 \{\par
843     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);\par
844 \par
845     double kernel[dim_kernel*dim_kernel];\par
846     \par
847     int m = (dim_kernel-1)/2;\par
848     \par
849     double gaussian =1/pow(3.1415*2*o*o,0.5);\par
850 \par
851     for(int i =-m; i <=m; i++)\par
852     \{\par
853         for(int j =-m; j<=+m; j++)\par
854         \{\par
855             double exp= -(i*i+j*j)*0.5/(o*o);\par
856             kernel[(i+m)*dim_kernel + (j+m)]=gaussian*pow(2.7,exp); \par
857             \par
858         \}\par
859     \}\par
860     \par
861     \par
862     \par
863     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
864     \{\par
865         for(unsigned int z = 0; z < this->get_depth(); z++)\par
866         \{\par
867             for(unsigned int x = m; x < this->get_width(); x++)\par
868             \{\par
869                 for(unsigned int y = m; y < this->get_height(); y++)\par
870                 \{\par
871                     int cont=0;\par
872                     unsigned char pixel=0;\par
873                     \par
874                     for(unsigned int i = x-m; i < x+m; i++)\par
875                     \{\par
876                         for(unsigned int j = y-m; j< y+m; j++)\par
877                         \{\par
878                             pixel+= this->get_pixel_value(i, j, z, c)*(kernel[cont]); \par
879                             cont++;\par
880                         \}\par
881                     \}\par
882                     filtered.set_pixel_value(x, y, z, c, (pixel/2));\par
883                 \}\par
884                 \par
885              \}\par
886              \par
887          \}\par
888     \}  \par
889      return filtered;       \par
890 \}   \par
}
}
{\xe \v filter_Gradient_horizontal\:Image}
{\xe \v Image\:filter_Gradient_horizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Gradient_horizontal (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This filter is used as as Sharpening Spatial Filter, used to identify borders and noise in the image. Can be used to identify horizontal borders or discrepation Applies the following filter: $ ((1, 2, 1) , (0, 0, 0) , (-1, -2, -1)) $ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An image object that contains the original image after receiving a gradient filter in the horizontal direction. Could be used to identify horizontal borders. \par
}}{
Definition at line 436 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 437 \{   \par
438     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
439     \par
440     int m = 1;\par
441     \par
442     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
443     \{\par
444         for(unsigned int z = 0; z < this->get_depth(); z++)\par
445         \{\par
446             for(unsigned int x = m; x < this->get_width()-m; x++)\par
447             \{\par
448                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
449                 \{\par
450                     int sum = this->get_pixel_value(x-1, y-1, z, c) + 2*(this->get_pixel_value(x, y-1, z, c)) + this->get_pixel_value(x+1, y-1, z, c) - (this->get_pixel_value(x-1, y+1, z, c) + 2*(this->get_pixel_value(x, y+1, z, c)) + this->get_pixel_value(x+1, y+1, z, c));\par
451                     if (sum > 255 || sum < -255)\par
452                     \{\par
453                         sum = 255;\par
454                     \}\par
455                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
456                     filtered.set_pixel_value(x, y, z, c, pixel);\par
457                 \}\par
458                 \par
459              \}\par
460              \par
461          \}\par
462     \}  \par
463      return filtered;\par
464 \}\par
}
}
{\xe \v filter_Gradient_vertical\:Image}
{\xe \v Image\:filter_Gradient_vertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Gradient_vertical (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This filter is used as as Sharpening Spatial Filter, used to identify borders and noise in the image. Can be used to identify vertical borders or discrepations. Applies the following filter: $ ((1, 0, -1) , (2, 0, -2) , (1, 0, -1)) $ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An image object that contains the original image after receiving a gradient filter in the vertical direction. Could be used to identify vertical borders. \par
}}{
Definition at line 473 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 474 \{\par
475     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
476     \par
477     int m = 1;\par
478     \par
479     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
480     \{\par
481         for(unsigned int z = 0; z < this->get_depth(); z++)\par
482         \{\par
483             for(unsigned int x = m; x < this->get_width()-m; x++)\par
484             \{\par
485                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
486                 \{\par
487                     int sum = get_pixel_value(x-1, y-1, z, c) + 2*get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) - (get_pixel_value(x+1, y-1, z, c) + 2*get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c));\par
488                     if (sum > 255 || sum < -255)\par
489                     \{\par
490                         sum = 255;\par
491                     \}\par
492                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
493                     filtered.set_pixel_value(x, y, z, c, pixel);\par
494                 \}\par
495                 \par
496              \}\par
497              \par
498          \}\par
499     \}  \par
500      return filtered;\par
501 \}\par
}
}
{\xe \v filter_horizontal_borders\:Image}
{\xe \v Image\:filter_horizontal_borders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_horizontal_borders (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 711 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 712 \{\par
713     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
714     \par
715     int m = 1;\par
716     \par
717     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
718     \{\par
719         for(unsigned int z = 0; z < this->get_depth(); z++)\par
720         \{\par
721             for(unsigned int x = 0; x < this->get_width()-m; x++)\par
722             \{\par
723                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
724                 \{\par
725                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(this->get_pixel_value(x, y-1, z, c) - get_pixel_value(x, y+1, z, c)));\par
726                     filtered.set_pixel_value(x, y, z, c, pixel);\par
727                 \}\par
728                 \par
729              \}\par
730              \par
731          \}\par
732     \}  \par
733      return filtered;\par
734 \}\par
}
}
{\xe \v filter_kirsch_0\:Image}
{\xe \v Image\:filter_kirsch_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_0 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 0\'B0. $(-3,-3,5)(-3,0,5)(-3,-3,5)$. }}\par
{
Definition at line 1228 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1229 \{\par
1230     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1231     \par
1232     int m = 1;\par
1233     \par
1234     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1235     \{\par
1236         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1237         \{\par
1238             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1239             \{\par
1240                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1241                 \{\par
1242                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c));\par
1243                     if (sum > 255 || sum < -255)\par
1244                     \{\par
1245                         sum = 255;\par
1246                     \}\par
1247                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1248                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1249                 \}\par
1250                 \par
1251              \}\par
1252              \par
1253          \}\par
1254     \}  \par
1255     \par
1256     return filtered;\par
1257     \par
1258 \}\par
}
}
{\xe \v filter_kirsch_135\:Image}
{\xe \v Image\:filter_kirsch_135}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_135 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 135\'B0. $(5,5,-3)(5,0,-3)(-3,-3,-3)$. }}\par
{
Definition at line 1335 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1336 \{\par
1337     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1338     int m = 1;\par
1339     \par
1340     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1341     \{\par
1342         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1343         \{\par
1344             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1345             \{\par
1346                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1347                 \{\par
1348                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x-1, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c));\par
1349                     if (sum > 255 || sum < -255)\par
1350                     \{\par
1351                         sum = 255;\par
1352                     \}\par
1353                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1354                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1355                 \}\par
1356                 \par
1357              \}\par
1358              \par
1359          \}\par
1360     \}  \par
1361     \par
1362     return filtered;\par
1363     \par
1364 \}\par
}
}
{\xe \v filter_kirsch_180\:Image}
{\xe \v Image\:filter_kirsch_180}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_180 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 180\'B0. $(5,-3,-3)(5,0,-3)(5,-3,-3)$. }}\par
{
Definition at line 1370 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1371 \{\par
1372     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1373     int m = 1;\par
1374     \par
1375     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1376     \{\par
1377         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1378         \{\par
1379             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1380             \{\par
1381                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1382                 \{\par
1383                     int sum = -3*(get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x-1, y-1, z, c));\par
1384                     if (sum > 255 || sum < -255)\par
1385                     \{\par
1386                         sum = 255;\par
1387                     \}\par
1388                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1389                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1390                 \}\par
1391                 \par
1392              \}\par
1393              \par
1394          \}\par
1395     \}  \par
1396     \par
1397     return filtered;\par
1398     \par
1399 \}\par
}
}
{\xe \v filter_kirsch_225\:Image}
{\xe \v Image\:filter_kirsch_225}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_225 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 225\'B0. $(-3,-3,-3)(5,0,-3)(5,5,-3)$. }}\par
{
Definition at line 1405 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1406 \{\par
1407     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1408     int m = 1;\par
1409     \par
1410     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1411     \{\par
1412         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1413         \{\par
1414             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1415             \{\par
1416                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1417                 \{\par
1418                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x+1, y+1, z, c))+5*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c));\par
1419                     if (sum > 255 || sum < -255)\par
1420                     \{\par
1421                         sum = 255;\par
1422                     \}\par
1423                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1424                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1425                 \}\par
1426                 \par
1427              \}\par
1428              \par
1429          \}\par
1430     \}  \par
1431     \par
1432     return filtered;\par
1433     \par
1434 \}\par
}
}
{\xe \v filter_kirsch_270\:Image}
{\xe \v Image\:filter_kirsch_270}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_270 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 270\'B0. $(-3,-3,-3)(-3,0,-3)(5,5,5)$. }}\par
{
Definition at line 1440 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1441 \{\par
1442     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1443     int m = 1;\par
1444     \par
1445     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1446     \{\par
1447         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1448         \{\par
1449             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1450             \{\par
1451                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1452                 \{\par
1453                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c))+5*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x-1, y+1, z, c));\par
1454                     if (sum > 255 || sum < -255)\par
1455                     \{\par
1456                         sum = 255;\par
1457                     \}\par
1458                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1459                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1460                 \}\par
1461                 \par
1462              \}\par
1463              \par
1464          \}\par
1465     \}  \par
1466     \par
1467     return filtered;\par
1468     \par
1469 \}\par
}
}
{\xe \v filter_kirsch_315\:Image}
{\xe \v Image\:filter_kirsch_315}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_315 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 315\'B0. $(-3,-3,-3)(-3,0,5)(-3,5,5)$. }}\par
{
Definition at line 1475 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1476 \{\par
1477     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1478     int m = 1;\par
1479     \par
1480     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1481     \{\par
1482         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1483         \{\par
1484             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1485             \{\par
1486                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1487                 \{\par
1488                     int sum = -3*(get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x+1, y-1, z, c))+5*(get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c));\par
1489                     if (sum > 255 || sum < -255)\par
1490                     \{\par
1491                         sum = 255;\par
1492                     \}\par
1493                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1494                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1495                 \}\par
1496                 \par
1497              \}\par
1498              \par
1499          \}\par
1500     \}  \par
1501     \par
1502     return filtered;\par
1503     \par
1504 \}\par
}
}
{\xe \v filter_kirsch_45\:Image}
{\xe \v Image\:filter_kirsch_45}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_45 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 45\'B0. $(-3,5,5)(-3,0,5)(-3,-3,-3)$. }}\par
{
Definition at line 1264 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1265 \{\par
1266     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1267     int m = 1;\par
1268     \par
1269     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1270     \{\par
1271         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1272         \{\par
1273             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1274             \{\par
1275                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1276                 \{\par
1277                     int sum = -3*(get_pixel_value(x-1, y-1, z, c)+get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x, y+1, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x+1, y, z, c)+get_pixel_value(x, y-1, z, c));\par
1278                     if (sum > 255 || sum < -255)\par
1279                     \{\par
1280                         sum = 255;\par
1281                     \}\par
1282                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1283                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1284                 \}\par
1285                 \par
1286              \}\par
1287              \par
1288          \}\par
1289     \}  \par
1290     \par
1291     return filtered;\par
1292     \par
1293     \par
1294 \}\par
}
}
{\xe \v filter_kirsch_90\:Image}
{\xe \v Image\:filter_kirsch_90}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_kirsch_90 (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the kirsch mask at 90\'B0. $(5,5,5)(-3,0-3)(-3,-3,-3)$. }}\par
{
Definition at line 1300 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1301 \{\par
1302     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1303     int m = 1;\par
1304     \par
1305     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1306     \{\par
1307         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1308         \{\par
1309             for(unsigned int x = m; x < this->get_width()-m; x++)\par
1310             \{\par
1311                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
1312                 \{\par
1313                     int sum = -3*(get_pixel_value(x-1, y, z, c)+get_pixel_value(x-1, y+1, z, c)+get_pixel_value(x, y+1, z, c)+get_pixel_value(x+1, y+1, z, c)+get_pixel_value(x+1, y, z, c))+5*(get_pixel_value(x+1, y-1, z, c)+get_pixel_value(x, y-1, z, c)+get_pixel_value(x-1, y-1, z, c));\par
1314                     if (sum > 255 || sum < -255)\par
1315                     \{\par
1316                         sum = 255;\par
1317                     \}\par
1318                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
1319                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1320                 \}\par
1321                 \par
1322              \}\par
1323              \par
1324          \}\par
1325     \}  \par
1326     \par
1327     return filtered;\par
1328     \par
1329 \}\par
}
}
{\xe \v filter_Laplacian\:Image}
{\xe \v Image\:filter_Laplacian}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Laplacian (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an image after applying the Laplacian filter to the image. Considers the diagonal values This function applies a convolution with this kernel: $ ((1, 1, 1), (1, -8, 1), (1, 1, 1)) $. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Filtered image with the Laplacian filter applied. \par
}}{
Definition at line 347 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 348 \{\par
349     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
350     \par
351     int m = 1;\par
352     \par
353     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
354     \{\par
355         for(unsigned int z = 0; z < this->get_depth(); z++)\par
356         \{\par
357             for(unsigned int x = m; x < this->get_width()-m; x++)\par
358             \{\par
359                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
360                 \{\par
361                     int sum = 0;\par
362                     \par
363                     for (unsigned int i = 0 ; i < 3; i++)\par
364                     \{\par
365                         for(unsigned int j = 0 ; j < 3; j++)\par
366                         \{\par
367                         sum += -this->get_pixel_value(x+i-1, y+i-1, z, c);\par
368                         \}\par
369                     \}\par
370                     \par
371                     sum += 9*(this->get_pixel_value(x,y,z,c));\par
372                     \par
373                     if (sum > 255 || sum < -255)\par
374                     \{\par
375                         sum = 255;\par
376                     \}\par
377                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
378                     filtered.set_pixel_value(x, y, z, c, pixel);\par
379                 \}\par
380                 \par
381              \}\par
382              \par
383          \}\par
384     \}  \par
385     return filtered; \par
386 \}\par
}
}
{\xe \v filter_Laplacian_no_diagonal\:Image}
{\xe \v Image\:filter_Laplacian_no_diagonal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Laplacian_no_diagonal (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Works as a derivative function, reacts to high change on the pixels value, especially to noise, and borders. Applies the following filter: $ ((0, -1, 0) , (-1, 4, -1) , (0, -1, 0)) $ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A filtered {\b Image} with the laplacian filter. \par
}}{
Definition at line 393 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 394 \{\par
395     //int kernel[9] = \{0, -1, 0, -1, 4, -1, 0, -1, 0\};\par
396     \par
397     //return (this->filter(kernel, 3, 1));\par
398     \par
399     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
400     \par
401     int m = 1;\par
402     \par
403     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
404     \{\par
405         for(unsigned int z = 0; z < this->get_depth(); z++)\par
406         \{\par
407             for(unsigned int x = m; x < this->get_width()-m; x++)\par
408             \{\par
409                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
410                 \{\par
411                     int sum = 4*(this->get_pixel_value(x,y,z,c)) - (this->get_pixel_value(x-1,y,z,c) + this->get_pixel_value(x+1,y,z,c) + this->get_pixel_value(x,y-1,z,c) +this->get_pixel_value(x,y+1,z,c));\par
412                     \par
413                     if (sum > 255 || sum < -255)\par
414                     \{\par
415                         sum = 255;\par
416                     \}\par
417                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
418                     filtered.set_pixel_value(x, y, z, c, pixel);\par
419                 \}\par
420                 \par
421              \}\par
422              \par
423          \}\par
424     \}  \par
425     return filtered; \par
426     \par
427 \}\par
}
}
{\xe \v filter_maximum\:Image}
{\xe \v Image\:filter_maximum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_maximum (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the highest value in the neighborhood. Assigns the highest value in the neighborhood around the desired pixel. }}\par
{
Definition at line 1795 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1796 \{\par
1797     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1798     \par
1799     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1800     \{\par
1801         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1802         \{\par
1803             for(unsigned int x = 1; x < this->get_width()-1; x++)\par
1804             \{\par
1805                 for(unsigned int y = 1; y < this->get_height()-1; y++)\par
1806                 \{\par
1807                     unsigned char max = 0;\par
1808                     \par
1809                     for (unsigned int i = x-1; i< x+2; i++)\par
1810                     \{\par
1811                         for (unsigned int j = y-1; j< y+2; j++)\par
1812                         \{\par
1813                             unsigned char pixel = (this->get_pixel_value(i, j, z, c));\par
1814                              \par
1815                             if (pixel > max)\par
1816                             \{\par
1817                                 max = this->get_pixel_value(i, j, z, c);\par
1818                             \}\par
1819                         \} \par
1820                     \}\par
1821                     \par
1822                     filtered.set_pixel_value(x, y, z, c, max);\par
1823                 \}\par
1824                 \par
1825              \}\par
1826              \par
1827          \}\par
1828     \}  \par
1829     return filtered;\par
1830 \}\par
}
}
{\xe \v filter_median\:Image}
{\xe \v Image\:filter_median}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_median (int {\i dim}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the median of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Only} \cell }{receives the dimension of the kernel (dim), wich only can be an impair number. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} filtered which is the image with the median filter applied. \par
}}{
Definition at line 747 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 748 \{\par
749     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
750     \par
751     //int kernel [dim*dim];\par
752 \par
753     int m = (dim-1)/2;\par
754     unsigned char pixel_values [dim*dim];\par
755     unsigned char temp;\par
756     \par
757     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
758     \{\par
759         for(unsigned int z = 0; z < this->get_depth(); z++)\par
760         \{\par
761             for(unsigned int x = m; x < this->get_width(); x++)\par
762             \{\par
763                 for(unsigned int y = m; y < this->get_height(); y++)\par
764                 \{\par
765                     for(unsigned int i = x-m; i < x+m; i++)\par
766                     \{\par
767                         for(unsigned int j = y-m; j< y+m; j++)\par
768                         \{\par
769                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);\par
770                             \par
771                         \}   \par
772                     \}\par
773                     for(int k=0; k<dim*dim ; k++)\par
774                     \{\par
775                         for(int p=k+1 ; p<dim*dim ; p++)\par
776                         \{\par
777                             if(pixel_values[p] < pixel_values[k])\par
778                             \{\par
779                             // Intercambiar los valores\par
780                             temp = pixel_values[k];\par
781                             pixel_values[k] = pixel_values[p];\par
782                             pixel_values[p] = temp;\par
783                             \}\par
784                         \}\par
785                     \}                   \par
786                     unsigned char pixel = pixel_values[((dim*dim-1)/2)-1];\par
787                     filtered.set_pixel_value(x, y, z, c, pixel);\par
788                 \}\par
789                 \par
790              \}\par
791              \par
792          \}\par
793     \}  \par
794      return filtered;\par
795  \}\par
}
}
{\xe \v filter_minimum\:Image}
{\xe \v Image\:filter_minimum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_minimum (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the highest value in the neighborhood. }}\par
{
Definition at line 1838 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1839 \{\par
1840     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1841     \par
1842     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1843     \{\par
1844         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1845         \{\par
1846             for(unsigned int x = 1; x < this->get_width()-1; x++)\par
1847             \{\par
1848                 for(unsigned int y = 1; y < this->get_height()-1; y++)\par
1849                 \{\par
1850                     unsigned char minimun = 255;\par
1851                     \par
1852                     for (unsigned int i = x-1; i< x+2; i++)\par
1853                     \{\par
1854                         for (unsigned int j = y-1; j< y+2; j++)\par
1855                         \{\par
1856                             if ((this->get_pixel_value(i, j, z, c)) < minimun)\par
1857                             \{\par
1858                                 minimun = this->get_pixel_value(i, j, z, c);\par
1859                             \}\par
1860                         \} \par
1861                     \}\par
1862                     \par
1863                     filtered.set_pixel_value(x, y, z, c, minimun);\par
1864                 \}\par
1865                 \par
1866              \}\par
1867              \par
1868          \}\par
1869     \}  \par
1870      return filtered;\par
1871 \}\par
}
}
{\xe \v filter_modal\:Image}
{\xe \v Image\:filter_modal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_modal (int {\i dim}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the modal of the range of pixels into the kernel and sets this value in the central pixel of the kernel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Only} \cell }{receives the dimension of the kernel (dim), wich only can be an impair number. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} filtered which is the image with the modal filter applied. \par
}}{
Definition at line 898 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 899 \{\par
900     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);\par
901     unsigned char pixel_values[dim*dim];\par
902     unsigned char moda;\par
903     unsigned char average=0;\par
904     int m=(dim-1)/2;\par
905     unsigned char copy_pixels[dim*dim];\par
906 \par
907     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
908     \{\par
909         for(unsigned int z = 0; z < this->get_depth(); z++)\par
910         \{\par
911             for(unsigned int x = m; x < this->get_width(); x++)\par
912             \{\par
913                 for(unsigned int y = m; y < this->get_height(); y++)\par
914                 \{\par
915                     for(unsigned int i = x-m; i < x+m; i++)\par
916                     \{\par
917                         for(unsigned int j = y-m; j< y+m; j++)\par
918                         \{\par
919                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);\par
920         \par
921                             int frequency[dim*dim];\par
922                             moda=0; \par
923                             \par
924                             for(int k=0;k<dim*dim;k++)\par
925                             \{\par
926                                 copy_pixels[k]= pixel_values[k];\par
927                                 frequency[k]=0;\par
928                             \}\par
929                             \par
930                             for(int p=0;p<dim*dim;p++)\par
931                             \{\par
932                                 for(int q=p+1;q<dim*dim;q++)\par
933                                 \{\par
934                                     if(copy_pixels[p]==pixel_values[q])\{\par
935                                         frequency[p]++;\par
936                                 \par
937                                     \}\par
938             \par
939                                 \}\par
940     \par
941                             \}\par
942 \par
943 \par
944 \par
945                             for(int s=0; s<dim*dim ; s++)\par
946                             \{\par
947                                 for(int e=s+1 ; e<dim*dim ; e++)\par
948                                 \{\par
949                                     if(frequency[e] < frequency[s])\par
950                                     \{\par
951                                         moda = copy_pixels[s];\par
952                                         average=copy_pixels[s];\par
953                                     \}\par
954                                 \}\par
955                             \}\par
956                             \par
957 \par
958                             if(moda==0)\par
959                             \{\par
960                                 for(int k=0;k<dim*dim;k++)\par
961                                 \{\par
962                                     moda += pixel_values[k];\par
963                                 \}\par
964                             average=(moda/dim);\par
965                             \}\par
966 \par
967 \par
968                         \}   \par
969                     \}\par
970                     \par
971                     filtered.set_pixel_value(x, y, z, c, average);\par
972                 \}\par
973                 \par
974              \}\par
975              \par
976          \}\par
977     \}\par
978 \par
979 return filtered;\par
980 \par
981 \}\par
}
}
{\xe \v filter_order_stadistics\:Image}
{\xe \v Image\:filter_order_stadistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_order_stadistics (int {\i dim}, int {\i order}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1873 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1874 \{\par
1875     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1876     \par
1877     //int kernel [dim*dim];\par
1878     \par
1879     int m = (dim-1)/2;\par
1880     \par
1881     unsigned char pixel_values [dim*dim];\par
1882     unsigned char temp;\par
1883     \par
1884     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1885     \{\par
1886         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1887         \{\par
1888             for(unsigned int x = m; x < this->get_width(); x++)\par
1889             \{\par
1890                 for(unsigned int y = m; y < this->get_height(); y++)\par
1891                 \{\par
1892                     for(unsigned int i = x-m; i < x+m+1; i++)\par
1893                     \{\par
1894                         for(unsigned int j = y-m; j< y+m+1; j++)\par
1895                         \{\par
1896                             pixel_values [(i-x+m)*dim + (j-y+m)]= this->get_pixel_value(i, j, z, c);\par
1897                             \par
1898                         \}   \par
1899                     \}\par
1900                     for(int k=0; k<dim*dim ; k++)\par
1901                     \{\par
1902                         for(int p=k+1 ; p<dim*dim ; p++)\par
1903                         \{\par
1904                             if(pixel_values[p] < pixel_values[k])\par
1905                             \{\par
1906                             // Intercambiar los valores\par
1907                             temp = pixel_values[k];\par
1908                             pixel_values[k] = pixel_values[p];\par
1909                             pixel_values[p] = temp;\par
1910                             \}\par
1911                         \}\par
1912                     \}                   \par
1913                     unsigned char pixel = pixel_values[order];\par
1914                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1915                 \}\par
1916                 \par
1917              \}\par
1918              \par
1919          \}\par
1920     \}  \par
1921      return filtered;\par
1922 \}\par
}
}
{\xe \v filter_Prewitt_E_W\:Image}
{\xe \v Image\:filter_Prewitt_E_W}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Prewitt_E_W (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 590 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 591 \{\par
592     //int kernel[9] = \{1, 0, -1, 1, 0, -1, 1, 0, -1\};\par
593     \par
594     //return (this->filter(kernel, 3, 1));  \par
595     \par
596     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
597     \par
598     int m = 1;\par
599     \par
600     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
601     \{\par
602         for(unsigned int z = 0; z < this->get_depth(); z++)\par
603         \{\par
604             for(unsigned int x = m; x < this->get_width()-m; x++)\par
605             \{\par
606                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
607                 \{\par
608                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) - (get_pixel_value(x+1, y-1, z, c) + get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c));\par
609                     if (sum > 255 || sum < -255)\par
610                     \{\par
611                         sum = 255;\par
612                     \}\par
613                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
614                     filtered.set_pixel_value(x, y, z, c, pixel);\par
615                 \}\par
616                 \par
617              \}\par
618              \par
619          \}\par
620     \}  \par
621     \par
622     return filtered;\par
623     \par
624 \}\par
}
}
{\xe \v filter_Prewitt_N_S\:Image}
{\xe \v Image\:filter_Prewitt_N_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Prewitt_N_S (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 520 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 521 \{\par
522     //int kernel[9] = \{1, 1, 1, 0, 0, 0, -1, -1, -1\};\par
523     \par
524     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
525     \par
526     int m = 1;\par
527     \par
528     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
529     \{\par
530         for(unsigned int z = 0; z < this->get_depth(); z++)\par
531         \{\par
532             for(unsigned int x = m; x < this->get_width()-m; x++)\par
533             \{\par
534                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
535                 \{\par
536                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x, y-1, z, c) + get_pixel_value(x+1, y-1, z, c) - (get_pixel_value(x-1, y+1, z, c) + get_pixel_value(x, y+1, z, c) + get_pixel_value(x+1, y+1, z, c));\par
537                     if (sum > 255 || sum < -255)\par
538                     \{\par
539                         sum = 255;\par
540                     \}\par
541                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
542                     filtered.set_pixel_value(x, y, z, c, pixel);\par
543                 \}\par
544                 \par
545              \}\par
546              \par
547          \}\par
548     \}  \par
549     \par
550     return filtered;\par
551     \par
552 \}\par
}
}
{\xe \v filter_Prewitt_NE_SW\:Image}
{\xe \v Image\:filter_Prewitt_NE_SW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Prewitt_NE_SW (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 554 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 555 \{\par
556     //int kernel[9] = \{0, 1, 1, -1, 0, 1, -1, -1, 0\};\par
557     \par
558     //return (this->filter(kernel, 3, 1));\par
559     \par
560     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
561     \par
562     int m = 1;\par
563     \par
564     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
565     \{\par
566         for(unsigned int z = 0; z < this->get_depth(); z++)\par
567         \{\par
568             for(unsigned int x = m; x < this->get_width()-m; x++)\par
569             \{\par
570                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
571                 \{\par
572                     int sum = get_pixel_value(x, y-1, z, c) + get_pixel_value(x+1, y-1, z, c) + get_pixel_value(x+1, y, z, c) - (get_pixel_value(x-1, y, z, c) + get_pixel_value(x-1, y+1, z, c) + get_pixel_value(x, y+1, z, c));\par
573                     if (sum > 255 || sum < -255)\par
574                     \{\par
575                         sum = 255;\par
576                     \}\par
577                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
578                     filtered.set_pixel_value(x, y, z, c, pixel);\par
579                 \}\par
580                 \par
581              \}\par
582              \par
583          \}\par
584     \}  \par
585     \par
586     return filtered;\par
587     \par
588 \}\par
}
}
{\xe \v filter_Prewitt_NW_SE\:Image}
{\xe \v Image\:filter_Prewitt_NW_SE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_Prewitt_NW_SE (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 626 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 627 \{\par
628     //int kernel[9] = \{-1, -1, 0, -1, 0, 1, 0, 1, 1\};\par
629     \par
630     // (this->filter(kernel, 3, 1));    \par
631     \par
632     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
633     \par
634     int m = 1;\par
635     \par
636     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
637     \{\par
638         for(unsigned int z = 0; z < this->get_depth(); z++)\par
639         \{\par
640             for(unsigned int x = m; x < this->get_width()-m; x++)\par
641             \{\par
642                 for(unsigned int y = m; y < this->get_height()-m; y++)\par
643                 \{\par
644                     int sum = get_pixel_value(x-1, y-1, z, c) + get_pixel_value(x-1, y, z, c) + get_pixel_value(x, y-1, z, c) - (get_pixel_value(x+1, y, z, c) + get_pixel_value(x+1, y+1, z, c) + get_pixel_value(x, y+1, z, c));\par
645                     if (sum > 255 || sum < -255)\par
646                     \{\par
647                         sum = 255;\par
648                     \}\par
649                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(sum));\par
650                     filtered.set_pixel_value(x, y, z, c, pixel);\par
651                 \}\par
652                 \par
653              \}\par
654              \par
655          \}\par
656     \}  \par
657     \par
658     return filtered;\par
659         \par
660 \}\par
}
}
{\xe \v filter_vertical_borders\:Image}
{\xe \v Image\:filter_vertical_borders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::filter_vertical_borders (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 686 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 687 \{\par
688     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
689     \par
690     int m = 1;\par
691     \par
692     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
693     \{\par
694         for(unsigned int z = 0; z < this->get_depth(); z++)\par
695         \{\par
696             for(unsigned int x = m; x < this->get_width()-m; x++)\par
697             \{\par
698                 for(unsigned int y = 0; y < this->get_height()-m; y++)\par
699                 \{\par
700                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (abs(this->get_pixel_value(x-1, y, z, c) - get_pixel_value(x+1, y, z, c)));\par
701                     filtered.set_pixel_value(x, y, z, c, pixel);\par
702                 \}\par
703                 \par
704              \}\par
705              \par
706          \}\par
707     \}  \par
708      return filtered;\par
709 \}\par
}
}
{\xe \v gaussian_noise\:Image}
{\xe \v Image\:gaussian_noise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::gaussian_noise (double {\i variance}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts an RGB image to gray scale. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function applies the gaussian noise to an image. The gaussian noise increases or decreases intensity to a pixel, depending of the variance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i variance} \cell }{this parameter is used to set the value of noise that is applied to the image. \cell }
{\row }
}
}{
Definition at line 1970 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1971 \{\par
1972     srand(1);\par
1973     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1974     \{\par
1975         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1976         \{\par
1977             for(unsigned int x = 0; x < this->get_width(); x++)\par
1978             \{\par
1979                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1980                 \{\par
1981                     double random= variance*(rand()-RAND_MAX/variance)/RAND_MAX;\par
1982                     unsigned char pixel= this->get_pixel_value(x,y,z,c) + random;\par
1983                     \par
1984                     if((pixel<255) & (pixel>0))\par
1985                     \{\par
1986                         (*(this->Img))(x, y, z, c)= pixel;\par
1987                     \}   \par
1988 \par
1989                 \}\par
1990                 \par
1991                 \par
1992              \}\par
1993              \par
1994          \}\par
1995     \}  \par
1996      \par
1997 \}\par
}
}
{\xe \v get_histogram\:Image}
{\xe \v Image\:get_histogram}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int * Image::get_histogram (unsigned int {\i c}, unsigned int {\i z})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns an array containing the values of the histogram points, in the desired channel and depth. An Histogram is measure of the frecquency of a intensity value in an image, and is often used as a parameter to improve the constrast and quality of the image. After observing the histogram ( see {\b plot_histogram()} ) you could ecualizate the image. \par
}{
Definition at line 1167 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1168 \{\par
1169     int histogram [256];\par
1170     for(int i = 0; i<256; i++)\par
1171     \{\par
1172     histogram[i] = 0;   \par
1173     \}\par
1174     \par
1175     if (c < this->get_spectrum() && z < this->get_depth())\par
1176     \{\par
1177         for(unsigned int x = 0; x < this->get_width(); x++)\par
1178         \{\par
1179             for(unsigned int y = 0; y < this->get_height(); y++)\par
1180             \{\par
1181                 unsigned char pixel_value = this->get_pixel_value(x,y,z,c);\par
1182                 (histogram[pixel_value])++;\par
1183             \}\par
1184         \}\par
1185     \}\par
1186     \par
1187     int* histogram_pointer = histogram;\par
1188     \par
1189     return histogram_pointer;\par
1190 \}\par
}
}
{\xe \v gray_scale\:Image}
{\xe \v Image\:gray_scale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::gray_scale (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns the lowest value in the neighborhood. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function converts an RGB image to one in gray scale. The library uses this conversion: f(x,y)= 0.11R+0.56G + 0.14B Where f is the intensity of the pixel on the gray scale and R,G and B the pixel values on the different channels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function returns the mochromathic image. \par
}}{
Definition at line 2136 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2137 \{\par
2138     Image gray_image (this->get_width() , this->get_height(), this->get_depth(), 1, 0); \par
2139 \par
2140 \par
2141     for(unsigned int z = 0; z < this->get_depth(); z++)\par
2142     \{\par
2143         for(unsigned int x = 0; x < this->get_width(); x++)\par
2144         \{\par
2145             for(unsigned int y = 0; y < this->get_height(); y++)\par
2146             \{\par
2147             \par
2148                 unsigned char pixel_intensity = 0.56*this->get_pixel_value(x,y,z,1)+0.14*this->get_pixel_value(x,y,z,0)+0.11*this->get_pixel_value(x,y,z,2);\par
2149                 gray_image.set_pixel_value(x, y, z, 0, pixel_intensity);\par
2150                 \par
2151             \}\par
2152              \par
2153          \}\par
2154     \}  \par
2155      return gray_image; \par
2156 \} \par
}
}
{\xe \v histogram_equalization\:Image}
{\xe \v Image\:histogram_equalization}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int* Image::histogram_equalization (int * , const char * {\i title})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v interpolation\:Image}
{\xe \v Image\:interpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::interpolation (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function doubles the size of the image and use the closer neighborhood interpolation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function returns the image interpolated. \par
}}{
Definition at line 2005 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2006 \{\par
2007     int i,j=0;\par
2008     Image result (2*this->get_width(),2*this->get_height(),this->get_depth(),this->get_spectrum(),0);\par
2009     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
2010     \{\par
2011         for(unsigned int z = 0; z < this->get_depth(); z++)\par
2012         \{\par
2013             for(unsigned int y = 0; y < this->get_width(); y++)\par
2014             \{\par
2015                 for(unsigned int x = 0; x < this->get_height(); x++)\par
2016                 \{\par
2017                     unsigned char pixel=this->get_pixel_value(x,y,z,c);\par
2018                     \par
2019                     result.set_pixel_value(x+i,y+j,z,c,pixel);\par
2020                     result.set_pixel_value(x+1+i,y+j,z,c,pixel);\par
2021                     result.set_pixel_value(x+i,y+1+j,z,c,pixel);\par
2022                     result.set_pixel_value(x+1+i,y+1+j,z,c,pixel);\par
2023                     i++;\par
2024                 \}\par
2025                 i=0;\par
2026                 j++;\par
2027             \}\par
2028             j=0;\par
2029         \}\par
2030     \}\par
2031     return result;\par
2032 \}\par
}
}
{\xe \v inverse\:Image}
{\xe \v Image\:inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::inverse (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes this transformation: $ v(x,y,z,c) = 255 - u(x,y,z,c) $ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An image object that contains the inverse of the original image, this means that every pixel value is substracted to 255. \par
}}{
Definition at line 994 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 995 \{\par
996     Image inverted (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
997 \par
998     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
999     \{\par
1000         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1001         \{\par
1002             for(unsigned int x = 0; x < this->get_width(); x++)\par
1003             \{\par
1004                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1005                 \{\par
1006                     unsigned char pixel= static_cast<unsigned int>(255-this->get_pixel_value(x,y,z,c));\par
1007                     inverted.set_pixel_value(x,y,z,c,pixel);\par
1008                 \}\par
1009             \}\par
1010         \}\par
1011     \}\par
1012     return inverted;\par
1013 \}\par
}
}
{\xe \v log_transformation\:Image}
{\xe \v Image\:log_transformation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::log_transformation (int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$ where v(x,y,z,c) is the transformed pixel, and u(x,y,z,c) is the original pixel. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An image object that contains the inverse of the original image, this means that every pixel value is substracted to 255. \par
}}{
Definition at line 1020 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1021 \{\par
1022     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1023 \par
1024     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1025     \{\par
1026         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1027         \{\par
1028             for(unsigned int x = 0; x < this->get_width(); x++)\par
1029             \{\par
1030                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1031                 \{\par
1032                     unsigned char pixel = static_cast<unsigned char>((255/log(256)) * log(1+this->get_pixel_value(x, y, z, c)));\par
1033                     \par
1034                     filtered.set_pixel_value(x,y,z,c, pixel);\par
1035                 \}\par
1036             \}\par
1037         \}\par
1038     \}\par
1039     return filtered;\par
1040 \}\par
}
}
{\xe \v median_omp\:Image}
{\xe \v Image\:median_omp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::median_omp (int , int )}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v multiply_img\:Image}
{\xe \v Image\:multiply_img}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::multiply_img (double {\i multiplier}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function multiplies the pixel values by a factor. If the pixel value is higher than 255, adjust the pixel value to 255. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{multiplier is the factor that mutiplies all the pixel values. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} result: Is the result of multiply the image. \par
}}{
Definition at line 273 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 274 \{\par
275     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0);\par
276     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
277     \{\par
278         for(unsigned int z = 0; z < this->get_depth(); z++)\par
279         \{\par
280             for(unsigned int x = 0; x < this->get_width(); x++)\par
281             \{\par
282                 for(unsigned int y = 0; y < this->get_height(); y++)\par
283                 \{\par
284                     unsigned char pixel= static_cast<unsigned int>(abs(this->get_pixel_value(x,y,z,c)*multiplier));\par
285                     if (pixel >255)\par
286                         pixel = 255;\par
287                     result.set_pixel_value(x,y,z,c,pixel);\par
288                 \}\par
289             \}\par
290         \}\par
291     \}\par
292     return result;\par
293 \}\par
}
}
{\xe \v plot_histogram\:Image}
{\xe \v Image\:plot_histogram}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::plot_histogram (int {\i levels}, const char * {\i title})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function plot the histogram, using the CImg histogram function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i levels} \cell }{is the number of bars or columns that appear in the histogram. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i title} \cell }{is the title of the histogram. \cell }
{\row }
}
}{
Definition at line 1197 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1198 \{\par
1199     CImg<unsigned char> img = this->Img->histogram(levels);\par
1200     \par
1201     CImgDisplay main_display (*(this->Img), title);\par
1202     \par
1203     img.display_graph(main_display, 3, 1, "Pixel Intensity", 0, 0, "Frequency", 0, 0);\par
1204 \}\par
}
}
{\xe \v plot_histogram_equalization\:Image}
{\xe \v Image\:plot_histogram_equalization}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::plot_histogram_equalization (int {\i levels}, const char * {\i title})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1211 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1212 \{\par
1213     CImg<unsigned char> img = this->Img->equalize(levels);\par
1214     \par
1215     CImgDisplay main_display (*(this->Img), title);\par
1216     \par
1217     img.display_graph(main_display, 3, 1, "Pixel Intensity", 0, 0, "Frequency", 0, 0);\par
1218 \}\par
}
}
{\xe \v power_law_transformatiom\:Image}
{\xe \v Image\:power_law_transformatiom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::power_law_transformatiom (double {\i exponent}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes this transformation: $ v(x,y,z,c) = c log(u(x,y,z,c)+1)$. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies a transformation given by the ecuation $ v(x,y) = c {u(x,y)}^{\gamma} $ where $ u(x,y) $ is the value of the non filtered image, and $ v(xy) $ is the intensity value in the filtered image. $ \gamma, c $ are constants. In this case $ \gamma $ is a parameter. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A filtered image with the power law transformation \par
}}{
Definition at line 1091 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1092 \{\par
1093     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
1094     \par
1095     double k = (pow(255, 1-exponent));\par
1096     \par
1097     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1098     \{\par
1099         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1100         \{\par
1101             for(unsigned int x = 0; x < this->get_width(); x++)\par
1102             \{\par
1103                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1104                 \{\par
1105                     double power_law = k * pow( (this->get_pixel_value(x,y,z,c)) , exponent);\par
1106                     unsigned char pixel = static_cast<unsigned char>(power_law);\par
1107                     filtered.set_pixel_value(x, y, z, c, pixel);\par
1108                 \}\par
1109                 \par
1110              \}\par
1111              \par
1112          \}\par
1113     \}  \par
1114     return filtered;\par
1115 \}\par
}
}
{\xe \v rgb_hsv\:Image}
{\xe \v Image\:rgb_hsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::rgb_hsv ()}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v salt_pepper\:Image}
{\xe \v Image\:salt_pepper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::salt_pepper (double {\i intensity}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put pepper (black pixels) and salt(white pixels) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i intensity} \cell }{is used to compute the percentage of salt and pepper that is applied to the image. \cell }
{\row }
}
}{
Definition at line 1933 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1934 \{\par
1935     srand(1);\par
1936     double percentage = 1-(intensity/100);\par
1937     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
1938     \{\par
1939         for(unsigned int z = 0; z < this->get_depth(); z++)\par
1940         \{\par
1941             for(unsigned int x = 0; x < this->get_width(); x++)\par
1942             \{\par
1943                 for(unsigned int y = 0; y < this->get_height(); y++)\par
1944                 \{\par
1945                     double random= 2.0*(rand()-RAND_MAX/2.0)/RAND_MAX;\par
1946                     if(random > percentage)\par
1947                     \{\par
1948                         (*(this->Img))(x, y, z, c)= 255;\par
1949                     \}   \par
1950 \par
1951                     else if(random<-1*percentage)\par
1952                     \{\par
1953                         (*(this->Img))(x, y, z, c)= 0;                  \par
1954                     \}\par
1955                 \}\par
1956                 \par
1957                 \par
1958              \}\par
1959              \par
1960          \}\par
1961     \}  \par
1962      \par
1963 \}\par
}
}
{\xe \v set_pixel_value\:Image}
{\xe \v Image\:set_pixel_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Image::set_pixel_value (int {\i x}, int {\i y}, int {\i z}, int {\i c}, unsigned char {\i value})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file image.cpp.}\par
{
Referenced by binarize_img(), color_slicing(), coorrelogram(), coorrelogram_ZC(), filter_average(), filter_dynamic_range_dilatation(), filter_edge_enhacement_displacement(), filter_freeman_0(), filter_freeman_1(), filter_freeman_2(), filter_freeman_3(), filter_freeman_4(), filter_freeman_5(), filter_freeman_6(), filter_freeman_7(), filter_gaussian(), filter_Gradient_horizontal(), filter_Gradient_vertical(), filter_horizontal_borders(), filter_kirsch_0(), filter_kirsch_135(), filter_kirsch_180(), filter_kirsch_225(), filter_kirsch_270(), filter_kirsch_315(), filter_kirsch_45(), filter_kirsch_90(), filter_Laplacian(), filter_Laplacian_no_diagonal(), filter_maximum(), filter_median(), filter_minimum(), filter_modal(), filter_order_stadistics(), filter_Prewitt_E_W(), filter_Prewitt_N_S(), filter_Prewitt_NE_SW(), filter_Prewitt_NW_SE(), filter_vertical_borders(), gray_scale(), interpolation(), inverse(), log_transformation(), multiply_img(), power_law_transformatiom(), substract_img(), sum_img(), and variance().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 140 \{\par
141     (*(this->Img))(x, y, z, c)= value;\par
142 \}\par
}
}
{\xe \v substract_img\:Image}
{\xe \v Image\:substract_img}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::substract_img ({\b Image} {\i image2}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function substracts the pixel values of two images, that can be used to see the differences between them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b Image}} \cell }{image2: Is the image that will be substracted to the original image. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Image} result: Is the result of the substraction of both images. \par
}}{
Definition at line 207 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 208 \{\par
209     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
210 \par
211     if(this->get_width() == image2.get_width() && this->get_height() == image2.get_height() && this->get_depth() == image2.get_depth() && this->get_spectrum() == image2.get_spectrum())\par
212     \{\par
213         for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
214         \{\par
215             for(unsigned int z = 0; z < this->get_depth(); z++)\par
216             \{\par
217                 for(unsigned int x = 0; x < this->get_width(); x++)\par
218                 \{\par
219                     for(unsigned int y = 0; y < this->get_height(); y++)\par
220                     \{\par
221                         unsigned char pixel= static_cast<unsigned int>(abs(this->get_pixel_value(x,y,z,c)-image2.get_pixel_value(x,y,z,c)));\par
222     \par
223                         result.set_pixel_value(x,y,z,c,pixel);\par
224                     \}\par
225                 \}\par
226             \}\par
227         \}\par
228     \}\par
229     return result;\par
230 \}\par
}
}
{\xe \v sum_img\:Image}
{\xe \v Image\:sum_img}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::sum_img ({\b Image} {\i image2}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 233 of file image.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 234 \{\par
235     Image result (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
236 \par
237     if(this->get_width() == image2.get_width() && this->get_height() == image2.get_height() && this->get_depth() == image2.get_depth() && this->get_spectrum() == image2.get_spectrum())\par
238     \{\par
239         for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
240         \{\par
241             for(unsigned int z = 0; z < this->get_depth(); z++)\par
242             \{\par
243                 for(unsigned int x = 0; x < this->get_width(); x++)\par
244                 \{\par
245                     for(unsigned int y = 0; y < this->get_height(); y++)\par
246                     \{\par
247                         unsigned char pixel;\par
248                         int sum = this->get_pixel_value(x,y,z,c)+image2.get_pixel_value(x,y,z,c);\par
249                         if (sum <= 255)\par
250                         \{\par
251                             pixel = static_cast<unsigned int>(sum);\par
252                         \}\par
253                         else\par
254                         \{\par
255                             pixel = 255;\par
256                         \}\par
257                         result.set_pixel_value(x,y,z,c,pixel);\par
258                     \}\par
259                 \}\par
260             \}\par
261         \}\par
262     \}\par
263     return result;\par
264 \}\par
}
}
{\xe \v variance\:Image}
{\xe \v Image\:variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Image} Image::variance (int {\i dim}, int {\i num_threads})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function compute the variance of an image. The variance is gived by the summation of the average multiplied by the substraction of the average with the pixel value, squared. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function returns the image interpolated. \par
}}{
Definition at line 2084 of file image.cpp.}\par
{
Referenced by gaussian_noise().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2085 \{\par
2086     Image filtered (this->get_width() , this->get_height(), this->get_depth(), this->get_spectrum(), 0); \par
2087     \par
2088     for(unsigned int c = 0; c < this->get_spectrum(); c++)\par
2089     \{\par
2090         for(unsigned int z = 0; z < this->get_depth(); z++)\par
2091         \{\par
2092             for(unsigned int x = dim; x < this->get_width()-dim; x++)\par
2093             \{\par
2094                 for(unsigned int y = dim; y < this->get_height()-dim; y++)\par
2095                 \{\par
2096                     int sum = 0;\par
2097                     double variance=0;\par
2098                     int kernel_values[(dim*2+1)*(dim*2+1)];\par
2099                     int cont=0;\par
2100 \par
2101                     for(unsigned int i = x-dim; i<= x+dim; i++)\par
2102                     \{\par
2103                         for(unsigned int j = y-dim; j<= y+dim; j++)\par
2104                         \{\par
2105                             sum += this->get_pixel_value(i, j, z, c);\par
2106                             kernel_values[cont]=this->get_pixel_value(i, j, z, c);\par
2107                             cont++;\par
2108                         \}\par
2109                     \}\par
2110             \par
2111                     double average =  sum/((dim*2+1)*(dim*2+1));\par
2112                     for(int i=0;i<(dim*2+1)*(dim*2+1);i++)\par
2113                     \{\par
2114                         variance+=pow(kernel_values[i]-average,2)/((dim*2+1)*(dim*2+1));\par
2115                     \}\par
2116                     \par
2117                     \par
2118                     unsigned char pixel = (unsigned char)static_cast<unsigned char> (variance);\par
2119                     filtered.set_pixel_value(x, y, z, c, pixel);\par
2120                 \}\par
2121                 \par
2122              \}\par
2123              \par
2124          \}\par
2125     \}  \par
2126      return filtered;\par
2127 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/include/{\b ParallelPic.hh}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/src/{\b image.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/src/{\b ParallelPic.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/include/ParallelPic.hh File Reference\par \pard\plain 
{\tc\tcl2 \v /home/fish/Documents/ParallelPic/Proyecto/include/ParallelPic.hh}
{\xe \v /home/fish/Documents/ParallelPic/Proyecto/include/ParallelPic.hh}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/CImg.h"}\par
{\f2 #include <string>}\par
{\f2 #include <cstddef>}\par
{\f2 #include <iostream>}\par
{\f2 #include <omp.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Image}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Image} class is the abstraction of the image, contains a CImg object that defines the handling of the image. }}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/src/image.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/fish/Documents/ParallelPic/Proyecto/src/image.cpp}
{\xe \v /home/fish/Documents/ParallelPic/Proyecto/src/image.cpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/image.hh"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/fish/Documents/ParallelPic/Proyecto/src/ParallelPic.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/fish/Documents/ParallelPic/Proyecto/src/ParallelPic.cpp}
{\xe \v /home/fish/Documents/ParallelPic/Proyecto/src/ParallelPic.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/ParallelPic.hh"}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}